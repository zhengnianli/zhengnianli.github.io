<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>正念君的博客</title>
  
  <subtitle>嵌入式大杂烩</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhengnianli.github.io/"/>
  <updated>2019-06-18T06:14:47.211Z</updated>
  <id>https://zhengnianli.github.io/</id>
  
  <author>
    <name>ZhengNian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【RT-Thread笔记】裸机系统与多线程系统</title>
    <link href="https://zhengnianli.github.io/2019/06/16/%E3%80%90RT-Thread%E7%AC%94%E8%AE%B0%E3%80%91%E8%A3%B8%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E7%BB%9F/"/>
    <id>https://zhengnianli.github.io/2019/06/16/【RT-Thread笔记】裸机系统与多线程系统/</id>
    <published>2019-06-16T05:59:36.000Z</published>
    <updated>2019-06-18T06:14:47.211Z</updated>
    
    <content type="html"><![CDATA[<p>单片机编程中有<code>裸机系统</code>与<code>多线程系统</code>的区别。</p><h3 id="裸机系统"><a href="#裸机系统" class="headerlink" title="裸机系统"></a>裸机系统</h3><p>裸机系统通常分成<code>轮询系统</code>和<code>前后台系统</code>。</p><h3 id="1、轮询系统"><a href="#1、轮询系统" class="headerlink" title="1、轮询系统"></a>1、轮询系统</h3><p>轮询系统即是在裸机编程的时候，先初始化好相关的硬件，然后让主程序在一个死循环里面不断循环，顺序地做各种事情，大概的伪代码具体如代码清单 1-1所示：</p><pre><code class="c">int main(void){ /* 硬件相关初始化 */ HardWareInit(); /* 无限循环 */ for (;;) {   /* 处理事情 1 */   DoSomething1();   /* 处理事情 2 */   DoSomethingg2();   /* 处理事情 3 */   DoSomethingg3(); }}</code></pre><p>轮询系统是一种非常简单的软件结构，通常只适用于那些只需要顺序执行代码且不需要外部事件来驱动的就能完成的事情。在代码清单 1-1 中，如果只是实现 LED 翻转，串口输出，液晶显示等这些操作，那么使用轮询系统将会非常完美。但是，如果加入了按键操作等需要检测外部信号的事件，用来模拟紧急报警，那么整个系统的实时响应能力就不会那么好了。</p><p>假设<code>DoSomethingg3</code> 是按键扫描，当外部按键被按下，相当于一个警报，这个时候，需要立马响 应 ， 并 做 紧 急 处 理 ， 而 这 个 时 候 程 序 刚 好 执 行 到 <code>DoSomethingg1</code> ， 要 命 的 是<code>DoSomethingg1</code> 需要执行的时间比较久，久到按键释放之后都没有执行完毕，那么当执行到 <code>DoSomethingg3</code> 的时候就会丢失掉一次事件。足见，轮询系统只适合顺序执行的功能代码，当有外部事件驱动时，实时性就会降低。</p><h3 id="2、前后台系统"><a href="#2、前后台系统" class="headerlink" title="2、前后台系统"></a>2、前后台系统</h3><p>相比轮询系统，前后台系统是在轮询系统的基础上加入了中断。外部事件的响应在中断里面完成，事件的处理还是回到轮询系统中完成，中断在这里我们称为前台， main 函数里面的无限循环我们称为后台，大概的伪代码见代码清单 1-2所示：</p><pre><code class="c">int flag1 = 0;int flag2 = 0;int flag3 = 0;int main(void){ /* 硬件相关初始化 */ HardWareInit(); /* 无限循环 */ for (;;) {   if (flag1) {     /* 处理事情 1 */     DoSomething1();   }   if (flag2) {     /* 处理事情 2 */     DoSomethingg2();   }   if (flag3) {     /* 处理事情 3 */     DoSomethingg3();   } }}void ISR1(void){ /* 置位标志位 */ flag1 = 1; /* 如果事件处理时间很短，则在中断里面处理 如果事件处理时间比较长，在回到后台处理 */ DoSomething1();}void ISR2(void){ /* 置位标志位 */ flag2 = 2; /* 如果事件处理时间很短，则在中断里面处理 如果事件处理时间比较长，在回到后台处理 */ DoSomething2();}void ISR3(void){ /* 置位标志位 */ flag3 = 1; /* 如果事件处理时间很短，则在中断里面处理 如果事件处理时间比较长，在回到后台处理 */ DoSomething3();}</code></pre><p>在顺序执行后台程序的时候，如果有中断来临，那么中断会打断后台程序的正常执行流，转而去执行中断服务程序，在中断服务程序里面标记事件，如果事件要处理的事情很简短，则可在中断服务程序里面处理，如果事件要处理的事情比较多，则返回到后台程序里面处理。</p><p>虽然事件的响应和处理是分开了，但是事件的处理还是在后台里面顺序执行的，但相比轮询系统，前后台系统确保了事件不会丢失，再加上中断具有可嵌套的功能，这可以大大的提高程序的实时响应能力。在大多数的中小型项目中，前后台系统运用的好，堪称有操作系统的效果。</p><h3 id="多线程系统"><a href="#多线程系统" class="headerlink" title="多线程系统"></a>多线程系统</h3><p>相比前后台系统，多线程系统的事件响应也是在中断中完成的，但是事件的处理是在线程中完成的。在多线程系统中，线程跟中断一样，也具有优先级，优先级高的线程会被优先执行。</p><p>当一个紧急的事件在中断被标记之后，如果事件对应的线程的优先级足够高，就会立马得到响应。相比前后台系统，多线程系统的实时性又被提高了。多线程系统大概的伪代码具体见代码清单 1-3所示：</p><pre><code class="c">int flag1 = 0;int flag2 = 0;int flag3 = 0;int main(void){ /* 硬件相关初始化 */ HardWareInit(); /* OS 初始化 */ RTOSInit(); /* OS 启动，开始多线程调度，不再返回 */ RTOSStart();}void ISR1(void){ /* 置位标志位 */ flag1 = 1;}void ISR2(void){ /* 置位标志位 */ flag2 = 2;}void ISR3(void){ /* 置位标志位 */ flag3 = 1;}void DoSomething1(void){ /* 无限循环，不能返回 */ for (;;) {   /* 线程实体 */   if (flag1) {   } }}void DoSomething2(void){ /* 无限循环，不能返回 */ for (;;) {   /* 线程实体 */   if (flag2) {   } }}void DoSomething3(void){ /* 无限循环，不能返回 */ for (;;) {   /* 线程实体 */   if (flag3) {   } }}</code></pre><p>相比前后台系统中后台顺序执行的程序主体，在多线程系统中，根据程序的功能，我们把这个程序主体分割成一个个独立的，无限循环且不能返回的小程序，这个小程序我们称之为<code>线程</code>。</p><p>每个线程都是独立的，互不干扰的，且具备自身的优先级，它由操作系统调度管理。加入操作系统后，我们在编程的时候不需要精心地去设计程序的执行流，不用担心每个功能模块之间是否存在干扰。</p><p>加入了操作系统，我们的编程反而变得简单了。整个系统随之带来的额外开销就是操作系统占据的那一丁点的 FLASH 和 RAM。现如今，单片机的 FLASH 和 RAM 是越来越大，完全足以抵挡 RTOS 那点开销。</p><p>轮询、前后台和多线程系统软件模型区别：</p><p><a href="https://imgchr.com/i/VTw6V1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/VTw6V1.md.png" alt="VTw6V1.md.png"></a></p><p>以上是关于裸机系统与多线程系统的笔记，摘抄于《RT-Thread内核实现与应用开发实践指南》一书。</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单片机编程中有&lt;code&gt;裸机系统&lt;/code&gt;与&lt;code&gt;多线程系统&lt;/code&gt;的区别。&lt;/p&gt;
&lt;h3 id=&quot;裸机系统&quot;&gt;&lt;a href=&quot;#裸机系统&quot; class=&quot;headerlink&quot; title=&quot;裸机系统&quot;&gt;&lt;/a&gt;裸机系统&lt;/h3&gt;&lt;p&gt;裸机系统通常分
      
    
    </summary>
    
      <category term="嵌入式" scheme="https://zhengnianli.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="嵌入式" scheme="https://zhengnianli.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】关于数组的一个陷阱！</title>
    <link href="https://zhengnianli.github.io/2019/06/03/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%B8%AA%E9%99%B7%E9%98%B1%EF%BC%81/"/>
    <id>https://zhengnianli.github.io/2019/06/03/【C语言笔记】关于数组的一个陷阱！/</id>
    <published>2019-06-03T00:22:15.000Z</published>
    <updated>2019-06-18T04:00:44.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>两个数组元素的地址相减得到什么？</p></blockquote><p>先看一段代码：</p><pre><code class="c">#include &lt;stdio.h&gt;int main(void){    int a[]={0,1,2,3,4,5};    printf(&quot;&amp;a[0] = %d, &amp;a[2] = %d\n&quot;, &amp;a[0], &amp;a[2]);    return 0;}</code></pre><p>这段代码以十进制的形式打印出第0号元素的地址和第2号元素的地址，输出结果为：</p><pre><code class="c">&amp;a[0] = 2686760, &amp;a[2] = 2686768</code></pre><p>所以，<code>&amp;a[2] - &amp;a[0]</code>的结果是8？但是，事实不是这样的！！让我们把其结果打印出来：<br><a href="https://imgchr.com/i/VqAEbd" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/VqAEbd.md.png" alt="VqAEbd.md.png"></a><br>竟然是<code>2</code>！我们把<code>&amp;a[5] - &amp;a[2]</code>的结果输出来看看有什么规律：<br><a href="https://imgchr.com/i/VqA1Kg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/VqA1Kg.md.png" alt="VqA1Kg.md.png"></a></p><h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>事实证明，两个数组元素的地址相减，其值并不是等于两个地址数值上的差，而是等于这两个地址之间内存单元的个数。本例中数组的类型是int类型，并且在32bit编译环境下编译，因此这里的内存单元的大小是4字节。所以本例中<code>&amp;a[2] - &amp;a[0]</code>的值为:</p><pre><code class="c">(2686768 - 2686760)/4</code></pre><p>当然，若是低号元素地址减去高号元素地址，得到的结果是负数：<br><a href="https://imgchr.com/i/VqAUP0" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/VqAUP0.md.png" alt="VqAUP0.md.png"></a><br>网上看到了一篇博客也是印证了这一点：</p><pre><code class="c">https://blog.csdn.net/harvic880925/article/details/8953854</code></pre><p>这是个很容易出错的问题，需要特别注意！</p><h2 id="学以致用"><a href="#学以致用" class="headerlink" title="学以致用"></a>学以致用</h2><p>我们的C语言每日一练（004）中的题目是</p><blockquote><p>寻找数组元素第一次出现的位置</p></blockquote><p>之前已经提供了两种方法，函数的返回值都是要寻找的元素的下标。这里可以稍微修改一下得到第三种方法，我们的第三种方法返回的是寻找的元素的指针：</p><pre><code class="c">// 函数返回找到元素的指针int *serch(int *arr,// 已知数表的首元指针          int n,   // 数表中元素个数          int key) // 要寻找的值{    int *p;    for (p = arr; p &lt; arr+n; p++)    {        if (*p == key)        {            return p;    // 返回找到元素的指针        }    }    return NULL;  // 未查找到key}</code></pre><h2 id="完整的验证代码为"><a href="#完整的验证代码为" class="headerlink" title="完整的验证代码为"></a>完整的验证代码为</h2><pre><code class="c">/********************************************************************************************************* 题    目: 同一个数组中两个元素的地址相减********************************************************************************************************/#include &lt;stdio.h&gt;// 函数返回找到元素的指针int *serch(int *arr,// 已知数表的首元指针          int n,   // 数表中元素个数          int key) // 要寻找的值{    int *p;    for (p = arr; p &lt; arr+n; p++)    {        if (*p == key)        {            return p;    // 返回找到元素的指针        }    }    return NULL;  // 未查找到key}// 定义一个全局数组int a[]={5,2,0,13,14,999,666, 55, 66, 88, 1, 5, 9};// 主函数int main(void){    int i, key;    int *p_a;    printf(&quot;The elements of array a is:\n&quot;);    for (i = 0; i &lt; sizeof(a)/sizeof(a[0]); i++)    {        printf(&quot; %d&quot;,a[i]);    }    puts(&quot;\nPlease input the key number you want to search:&quot;);    scanf(&quot;%d&quot;, &amp;key);    p_a = serch(a, sizeof(a)/sizeof(a[0]), key);    printf(&quot;\nThe index of the key number %d in the array is: %d.&quot;, key, p_a-a);    return 0;} </code></pre><p>可见，得到的结果与我们C语言每日一练（004）中的验证结果一样。</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;两个数组元素的地址相减得到什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先看一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;c
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】#运算符与##运算符</title>
    <link href="https://zhengnianli.github.io/2019/05/07/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E##%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://zhengnianli.github.io/2019/05/07/【C语言笔记】#运算符与##运算符/</id>
    <published>2019-05-07T00:22:15.000Z</published>
    <updated>2019-06-18T04:25:48.217Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、-运算符"><a href="#1、-运算符" class="headerlink" title="1、#运算符"></a>1、#运算符</h3><p>我们平时使用带参宏时，字符串中的宏参数是没有被替换的。例如：</p><p><a href="https://imgchr.com/i/VbbRo9" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/VbbRo9.md.png" alt="VbbRo9.md.png"></a></p><p>输出结果为：</p><p><a href="https://imgchr.com/i/VbbqdH" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/VbbqdH.md.png" alt="VbbqdH.md.png"></a></p><p>然而，我们期望输出的结果是：</p><pre><code class="c">5 + 20 = 2513 + 14 = 27</code></pre><p>这该怎么做呢？其实，C语言允许在字符串中包含宏参数。在类函数宏（带参宏）中，<code>#号</code>作为一个<code>预处理运算符</code>，可以<code>把记号转换成字符串</code>。例如，如果A是一个宏形参，那么#A就是转换为字符串”A”的形参名。这个过程称为<code>字符串化（stringizing）</code>。以下程序演示这个过程：</p><p><a href="https://imgchr.com/i/Vbq9OS" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/Vbq9OS.md.png" alt="Vbq9OS.md.png"></a></p><p>输出结果为：</p><p><a href="https://imgchr.com/i/VbqiwQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/VbqiwQ.md.png" alt="VbqiwQ.md.png"></a></p><p>这就达到我们想要的结果了。所以，<code>#运算符</code>可以完成<code>字符串化（stringizing）</code>的过程。</p><h3 id="2、-运算符"><a href="#2、-运算符" class="headerlink" title="2、##运算符"></a>2、##运算符</h3><p>与#运算符类似，<code>##运算符</code>可用于类函数宏（带参宏）的替换部分。<code>##运算符</code>可以把两个记号组合成一个记号。例如，可以这样做：</p><pre><code class="c">#define XNAME(n) x##n</code></pre><p>然后，宏XNAME(4)将展开x4。以下程序演示##运算符的用法：</p><p><a href="https://imgchr.com/i/VbqEYn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/VbqEYn.md.png" alt="VbqEYn.md.png"></a></p><p>输出结果为：</p><p><a href="https://imgchr.com/i/VbqdmD" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/VbqdmD.md.png" alt="VbqdmD.md.png"></a></p><p>注意：<code>PRINT_XN()</code>宏用<code>#运算符</code>组合字符串，<code>##运算符</code>把记号组合为一个新的标识符。</p><p>其实，<code>##运算符</code>在这里看来并没有起到多大的便利，反而会让我们感觉到不习惯。但是，使用<code>##运算符</code>有时候是可以提高封装性及程序的可读性的。如跑实时操作系统的stm32程序中，关于gpio的硬件驱动中有如下代码：</p><pre><code class="c">#define __STM32_PIN(index, gpio, gpio_index) \{ \index, GPIO##gpio##_CLK_ENABLE, GPIO##gpio, GPIO_PIN_##gpio_index \}</code></pre><p>假设这样使用该宏：</p><pre><code class="c">__STM32_PIN(7, C, 13)</code></pre><p>该宏将展开为：</p><pre><code class="c">{7, GPIOC_CLK_ENABLE, GPIOC, GPIO_PIN_13}</code></pre><p>然后这就可以很方便的将要使用的硬件引脚这么一一列出来，然后再拿去进行配置：</p><p>以上就是关于#运算符与##运算符的笔记，用#运算符组合字符串，##运算符把记号组合为一个新的标识符。如有错误欢迎指出。资料：『RT-Thread-IoT代码』、『C Primer Plus』。</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、-运算符&quot;&gt;&lt;a href=&quot;#1、-运算符&quot; class=&quot;headerlink&quot; title=&quot;1、#运算符&quot;&gt;&lt;/a&gt;1、#运算符&lt;/h3&gt;&lt;p&gt;我们平时使用带参宏时，字符串中的宏参数是没有被替换的。例如：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】带参宏定义（二）</title>
    <link href="https://zhengnianli.github.io/2019/03/26/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91%E5%B8%A6%E5%8F%82%E5%AE%8F%E5%AE%9A%E4%B9%89%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://zhengnianli.github.io/2019/03/26/【C语言笔记】带参宏定义（二）/</id>
    <published>2019-03-26T00:22:15.000Z</published>
    <updated>2019-06-18T02:53:23.532Z</updated>
    
    <content type="html"><![CDATA[<p>带参宏在我们的嵌入式编程中使用得非常多，其定义如下：</p><pre><code class="c">define 标识符(参数列表) 字符序列</code></pre><p>其中参数列表中的参数之间用逗号分隔，字符序列中应包含参数表中的参数。在定义带参数的宏时，宏名标识符与左圆括号之间不允许有空白符，应紧接在一起，否则变成了无参数的宏定义。</p><p>并且，字符序列与其每一个参数必须用括号扩起来，否则该宏定义可能会产生<code>二义性</code> 。下面举个简单的例子，定义一个求平方的宏函数：</p><pre><code class="c">#include &lt;stdio.h&gt;#define SQUARE(a) a*a // 不严谨的写法int main(void){  int x = 5;  int res = 0;  res = SQUARE(x+2);  printf(&quot;res = %d\n&quot;, res);  return 0;}</code></pre><p>输出结果如下：<br><a href="https://imgchr.com/i/VbO7LT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/VbO7LT.md.png" alt="VbO7LT.md.png"></a><br><code>res</code>变量的输出结果为17，与我们期望的<code>res = 49;</code>相差甚远！这就是因为我们不给字符序列中的宏参数加括号的原因，产生了歧义。程序生成可执行程序之前的预处理过程中把SQUARE(x+2)替换成了<code>x+2*x+2</code>，因此当<code>x=5</code>时res的结果为17。我们可以使用命令<code>gcc -E hello.c -o hello.i</code>进行预处理，然后查看经过预处理得到的文件<code>hello.i</code>的内容，<code>hello.i</code>里的内容如下：<br><a href="https://imgchr.com/i/VbOqwF" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/VbOqwF.md.png" alt="VbOqwF.md.png"></a><br><code>hello.i</code>里的内容与我们上面分析的一致！关于C程序的编译原理可查看往期笔记：<a href="https://zhengnianli.github.io/2018/10/14/c-yu-yan-bi-ji-c-yu-yan-bian-yi-de-guo-cheng/">【C语言笔记】C语言编译的过程</a>关于windows系统下使用<code>gcc编译器</code>的方法可参考往期笔记：<a href="https://zhengnianli.github.io/2018/10/05/c-yu-yan-bi-ji-shi-yong-notepad-mingw-lai-kai-fa-c-cheng-xu/">【C语言笔记】使用notepad++、MinGW来开发C程序</a></p><p>以上程序严谨的求平方的宏函数的定义如下：</p><pre><code class="c">#include &lt;stdio.h&gt;#define SQUARE(a) ((a)*(a)) // 严谨的做法int main(void){  int x = 5;  int res = 0;  res = SQUARE(x+2);  printf(&quot;res = %d\n&quot;, res);  return 0;}</code></pre><p>程序输出结果如下：<br><a href="https://imgchr.com/i/VbjPcq" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/VbjPcq.md.png" alt="VbjPcq.md.png"></a><br>可见，这才是我们要的正确结果。</p><p>带参宏到底有多重要，看看TI的一些官方例程就知道，其把很多算法使用带参宏封装起来，用户就可以很方便的使用。</p><h5 id="带参宏——-clarke变换算法："><a href="#带参宏——-clarke变换算法：" class="headerlink" title="带参宏—— clarke变换算法："></a>带参宏—— clarke变换算法：</h5><p><a href="https://imgchr.com/i/VbjABT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/VbjABT.md.png" alt="VbjABT.md.png"></a></p><h5 id="带参宏——-PI调节器算法："><a href="#带参宏——-PI调节器算法：" class="headerlink" title="带参宏—— PI调节器算法："></a>带参宏—— PI调节器算法：</h5><p><a href="https://imgchr.com/i/VbjEHU" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/VbjEHU.md.png" alt="VbjEHU.md.png"></a></p><h5 id="这些-h文件都使用宏来封装各种算法："><a href="#这些-h文件都使用宏来封装各种算法：" class="headerlink" title="这些.h文件都使用宏来封装各种算法："></a>这些.h文件都使用宏来封装各种算法：</h5><p><a href="https://imgchr.com/i/VbjeN4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/VbjeN4.md.png" alt="VbjeN4.md.png"></a></p><p>同样，ST官方固件库中也大量使用带参宏：<br><a href="https://imgchr.com/i/Vbj8HO" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/Vbj8HO.md.png" alt="Vbj8HO.md.png"></a><br><a href="https://imgchr.com/i/Vbjrb8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/Vbjrb8.md.png" alt="Vbjrb8.md.png"></a><br><a href="https://imgchr.com/i/Vbj5rV" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/Vbj5rV.md.png" alt="Vbj5rV.md.png"></a><br>可见带参宏定义的重要性！除此之外，通过以上宏定义，可发现很多宏定义分行时，其行后都加上反斜杠<code>\</code>进行分隔，这也是需要注意的细节。</p><h3 id="带参宏与函数的区别"><a href="#带参宏与函数的区别" class="headerlink" title="带参宏与函数的区别"></a>带参宏与函数的区别</h3><p>查看以上带参宏，我们发现带参宏似乎与函数似乎长得很像，它们之间有什么区别和联系呢？TI为什么要使用宏来对一些算法进行封装呢，难道使用函数来封装不可以吗？答案是可以的：<br><a href="https://imgchr.com/i/VbjIbT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/18/VbjIbT.md.png" alt="VbjIbT.md.png"></a><br>TI也说了，使用者可以很方便地把这些算法宏转换成一些函数。换句话说就是你可以使用宏定义，也可以使用函数。那么，什么时候封装成宏定义比较好，什么时候封装成函数比较好呢？</p><p>以下内容参考文章：<br><a href="http://blog.sina.com.cn/s/blog_861912cd0100tc94.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_861912cd0100tc94.html</a><br>下面，先看一下带参宏与函数的一些区别，举个例子，比较两个数或者表达式大小：</p><p>（1）带参宏的方式：</p><pre><code class="c">#define MAX(a,b) ((a)&gt;(b)?(a):(b))</code></pre><p>（2）函数封装的方式：</p><pre><code class="c">int max(int a, int b){　　return (a &gt; b ? a : b);}</code></pre><p>很显然，我们不会选择用函数来完成这个任务，原因有两个：</p><p>（1）首先，函数调用会带来额外的开销，它需要开辟一片栈空间，记录返回地址，将形参压栈，从函数返回还要释放堆栈。这种开销不仅会降低代码效率，而且代码量也会大大增加，而使用宏定义则在代码规模和速度方面都比函数更胜一筹；</p><p>（2）其次，函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用，我们如果要比较两个浮点型的大小，就不得不再写一个专门针对浮点型的比较函数。反之，上面的那个宏定义可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用“&gt;”操作符比较值大小的类型，也就是说，宏是与类型无关的。</p><p>除此之外，宏与函数的不同点还有：宏是在预处理阶段展开，占用的是编译时间，函数实在程序运行时调用的，占用的是程序运行的时间；宏参数没有类型说明，也没有返回值的概念。</p><p>和使用函数相比，使用宏的不利之处在于每次使用宏时，一份宏定义代码的拷贝都会插入到程序中。除非宏非常短，否则使用宏会大幅度增加程序的长度。</p><p>还有一些任务根本无法用函数实现，但是用宏定义却很好实现。比如参数类型没法作为参数传递给函数，但是可以把参数类型传递给带参的宏。</p><p>看下面的例子：</p><pre><code class="c">#define MALLOC（n, type）\　　（(type *) malloc（（n）* sizeof（type）））</code></pre><p>利用这个宏，我们就可以为任何类型分配一段我们指定的空间大小，并返回指向这段空间的指针。我们可以观察一下这个宏确切的工作过程：</p><pre><code class="c">int *ptr;ptr = MALLOC(5, int);</code></pre><p>将这宏展开以后的结果：</p><pre><code class="c">ptr = (int *)malloc((5) * sizeof(int));</code></pre><p>这个例子是宏定义的经典应用之一，完成了函数不能完成的功能，但是宏定义也不能滥用，通常，如果相同的代码需要出现在程序的几个地方，更好的方法是把它实现为一个函数。</p><h3 id="宏的缺点"><a href="#宏的缺点" class="headerlink" title="宏的缺点"></a>宏的缺点</h3><ul><li>宏可能会大幅度增加程序的长度。</li><li>宏是没法调试的。</li><li>宏由于与类型无关，也就不够严谨。</li><li>宏可能会带来运算符的优先级问题，即二义性。</li></ul><p>以上就是关于带参宏的一些总结，如有错误，欢迎指出！</p><hr><p>我的微信公众号如下，欢迎扫码关注查看更多分享：<br><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;带参宏在我们的嵌入式编程中使用得非常多，其定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;define 标识符(参数列表) 字符序列&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中参数列表中的参数之间用逗号分隔，字符序列中应包含参数表中的参数。在定义带参数的宏时，宏名标
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】带参宏定义（一）</title>
    <link href="https://zhengnianli.github.io/2019/03/23/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91%E5%B8%A6%E5%8F%82%E5%AE%8F%E5%AE%9A%E4%B9%89%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://zhengnianli.github.io/2019/03/23/【C语言笔记】带参宏定义（一）/</id>
    <published>2019-03-23T00:22:15.000Z</published>
    <updated>2019-06-17T14:23:39.147Z</updated>
    
    <content type="html"><![CDATA[<p>公司某项目用到<code>DSP+FPGA</code>架构（当然不是著名的ARM+DSP+FPGA点灯项目,哈哈），我的发展方向为DSP方向。其中DSP与FPGA通过两个带参宏进行数据交互（DSP与FPGA通过一块共享内存来实现数据交互，我这边的DSP只要往共享内存中写入数据即为往FPGA中写数据，往共享内存中读取数据就是读取FPGA发送过来的数据），如下图：</p><div align="center">[![VbYz7t.md.png](https://s2.ax1x.com/2019/06/17/VbYz7t.md.png)](https://imgchr.com/i/VbYz7t)<p>也即：</p><pre><code class="cpp">#define FPGA_WRITE(data_out, base_addr, offset)  \((((volatile uint32*)base_addr)[(offset)]) = (data_out))#define FPGA_READ(data_in, base_addr, offset)    \((data_in) = (((volatile uint32*)base_addr)[(offset)]))</code></pre><p>带参宏也称做<code>宏函数</code>，宏函数<code>FPGA_WRITE(data_out, base_addr, offset)</code>用于往FPGA发送数据。其中</p><ul><li><p><strong>参数data_out：</strong>要写入的数据。</p></li><li><p><strong>参数base_addr：</strong>基地址。</p></li><li><p><strong>参数offset：</strong>相对于基地址的偏移量。</p></li></ul><p>该宏函数实体为：</p><pre><code class="cpp">((((volatile uint32*)base_addr)[(offset)]) = (data_out))</code></pre><p>我们先看等号左边，从最里层的括号开始看，<code>(volatile uint32*)base_addr</code>的意思是把<code>base_addr</code>强制转换为<code>(volatile uint32*)</code>类型的数据，其中加volatile关键字的作用是确保本条指令不会因编译器的优化而省略。volatile在嵌入式编程中用得很多，如在Cortex-M3内核MCU的内核文件的C函数内嵌汇编中使用了大量的volatile关键字：</p><div align="center">[![VbtpAP.md.png](https://s2.ax1x.com/2019/06/17/VbtpAP.md.png)](https://imgchr.com/i/VbtpAP)<p>关于volatile关键字更多的介绍可查看往期分享：<br><a href="https://blog.csdn.net/zhengnianli/article/details/87478810" target="_blank">来看一看volatile关键字</a></p><p><code>((volatile uint32*)base_addr)[(offset)]</code>的意思是相对于base_addr偏移offset个内存单元后所占的空间，此时已经转变为了<code>base_addr[offset]</code>，这就可以看做数组base_addr的第offset个元素，所以可以给它赋值。等号右边的数据data_out就是给数组元素base_addr[offset]进行赋值的。数组和指针在此处其实是可以等价的，所以</p><pre><code class="cpp">((volatile uint32*)base_addr)[(offset)]</code></pre><p>其实可以等价为：</p><pre><code class="cpp">*(((volatile uint32*)base_addr) + offset)</code></pre><p>宏函数<code>FPGA_READ(data_in, base_addr, offset)</code>用于读取FPGA发送过来的数据，其实体为：</p><pre><code class="CPP">((data_in) = (((volatile uint32*)base_addr)[(offset)]))</code></pre><p>同写函数的分析方法类似，此处从等号右边的最里层括号开始看，分析过程省略，具体的可查看写数据函数<code>FPGA_WRITE</code>的分析过程。此处等号右边的</p><pre><code class="cpp">(((volatile uint32*)base_addr)[(offset)]))</code></pre><p>可以等价于：</p><pre><code class="cpp">*(((volatile uint32*)base_addr) + offset))</code></pre><p>为什么要在宏函数实体的参数的两边加上括号呢？为什么要在宏函数实体的两边加上括号呢？</p><p>答：虽然有时候不加括号也没什么问题，但是，更严格的做法是给参数加括号、给宏函数实体加括号，这样可以避免<strong><code>二义性</code></strong>。关于宏函数的二义性将在下一篇笔记中分享，欢迎阅读！</p><h3 id="以上两个带参宏的测试用例"><a href="#以上两个带参宏的测试用例" class="headerlink" title="以上两个带参宏的测试用例"></a>以上两个带参宏的测试用例</h3><pre><code class="java">/********************************************************************************* 宏函数FPGA_WRITE、FPGA_READ测试用例******************************************************************************/#include &lt;stdio.h&gt;#define uint32 unsigned int#if 1// 调用这两个宏可往共享内存中读写数据#define FPGA_WRITE(data_out, base_addr, offset) \((((volatile uint32*)base_addr)[(offset)]) = (data_out))#define FPGA_READ(data_in, base_addr, offset) \((data_in) = (((volatile uint32*)base_addr)[(offset)]))#else// 以上宏等效的写法#define FPGA_WRITE(data_out, base_addr, offset) \(*(((volatile uint32*)base_addr) + offset) = (data_out))#define FPGA_READ(data_in, base_addr, offset) \((data_in) = *(((volatile uint32*)base_addr) + offset))#endifint main(void){  // 变量定义  uint32 arr[6] = {0, 1, 2, 3, 4, 5};  uint32 *ptr = arr;  uint32 data_write = 520;  uint32 data_read = 0;  // 验证宏函数FPGA_WRITE  FPGA_WRITE(data_write, ptr, 3); // 此时arr[3]的值会被data_write的值覆盖  printf(&quot;arr[3] = %d\n&quot;, arr[3]);  if (data_write == arr[3])  {    printf(&quot;宏函数FPGA_WRITE验证成功！\n\n&quot;);  }  // 验证宏函数FPGA_READ  FPGA_READ(data_read, ptr, 5); // 此时data_read的值会被arr[5]的值覆盖  printf(&quot;data_read = %d\n&quot;, data_read);  if (data_read == arr[5])  {    printf(&quot;宏函数FPGA_READ验证成功！\n&quot;);  }  return 0;}</code></pre><p><strong>以上的测试方法是：</strong>定义一个数组arr，定义一个基地址ptr（指针变量），基地址ptr指向arr，此时ptr就可以与数组arr相关联起来了，即相对于ptr偏移offset个内存单元其实就是等价于arr[offset]。</p><pre><code class="cpp">FPGA_WRITE(data_write, ptr, 3);</code></pre><p>这条语句的意思就是往ptr往后第3个内存单元写入数据data_write，即<code>arr[3] = data_write;</code>，arr[3]由原来的3变成了520。</p><pre><code class="cpp">FPGA_READ(data_read, ptr, 5);</code></pre><p> 这条语句的意思就是把ptr往后第5个内存单元中的数据赋给data_read变量，即data_read = arr[5];，data_read由原来的0变成了5。程序运行结果如下：</p><div align="center">![Vbti9S.png](https://s2.ax1x.com/2019/06/17/Vbti9S.png)<p>可见，程序输出结果与我们分析的一致！带参宏很重要，在一定程度上可以帮助我们防止出错，<strong><code>提高代码的可移植性和可读性</code></strong>等，应重点掌握。下一篇笔记我们将分享更多的带参宏的笔记，欢迎阅读。</p><hr><p>我的微信公众号如下，欢迎扫码关注查看更多分享：</p><div align="center">[![VcSFJJ.md.png](https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png)](https://imgchr.com/i/VcSFJJ)</div></div></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;公司某项目用到&lt;code&gt;DSP+FPGA&lt;/code&gt;架构（当然不是著名的ARM+DSP+FPGA点灯项目,哈哈），我的发展方向为DSP方向。其中DSP与FPGA通过两个带参宏进行数据交互（DSP与FPGA通过一块共享内存来实现数据交互，我这边的DSP只要往共享内存中写入
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】指定初始化器</title>
    <link href="https://zhengnianli.github.io/2019/02/16/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8/"/>
    <id>https://zhengnianli.github.io/2019/02/16/【C语言笔记】指定初始化器/</id>
    <published>2019-02-16T00:22:15.000Z</published>
    <updated>2019-06-17T14:35:39.132Z</updated>
    
    <content type="html"><![CDATA[<p> <code>C99</code>增加了一个新特性：<code>指定初始化器(designated initializer)</code>。利用该特性可以初始化指定的数组元素，也可以初始化指定的结构体变量（往期笔记<a href="http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA==&mid=100000833&idx=1&sn=877ad9e1832cc45e983545fa0b148c18&chksm=7e0d6a86497ae390919fb4ba80327588daa49c177b627408c490141c9f47815142398fae5ca0#rd" target="_blank" rel="noopener">【C语言笔记】结构体</a>有用到这个特性对结构体变量进行初始化）。</p><p>本笔记主要分享：使用指定初始化器初始化数组。</p><blockquote><p>例如，只初始化数组中的最后一个元素。</p></blockquote><p>对于传统的C初始化语法，必须初始化最后一个元素所有元素，才能初始化它：</p><pre><code class="cpp">int arr[6] = {0,0,0,0,0,212); //传统的语法</code></pre><p>而<code>C99</code>规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素：</p><pre><code class="cpp">int arr[6] = {[5] = 212}; //把arr[5]初始化为212</code></pre><p>对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置为0。</p><p>下面看一段程序：</p><pre><code class="cpp">/* designate.c--使用指定初始化器 */#include &lt;stdio.h&gt;#define MONTHS 12int main (void){ int days[MONTHS] = {31,28,[4]=31,30,31,[1]=29}; int i; for (i = 0; i &lt; MONTHS; i++) {   printf(&quot;%2d  %d\n&quot;, i+1, days[i]); } return 0;}</code></pre><p>该程序在支持<code>C99</code>的编译器中输出如下：</p><pre><code class="cpp"> 1  31 2  29 3  0 4  0 5  31 6  30 7  31 8  0 9  010  011  012  0</code></pre><p>以上输出揭示了指定初始化器的两个重要特性：</p><p>【第一】如果指定初始化器后面有更多的值，如该例中的初始化列表中的片段： <code>[4] =31, 30, 31</code>，那么后面这些值将被用于初始化指定元素后面的元素。也就是说，在<code>days[4]</code>被初始化为31后，<code>days[5]</code>和<code>days[6]</code>将分别被初始化为30和31；</p><p>【第二】，如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。本例中，初始化列表开始时把<code>days[1]</code>初始化为28，但是days[1]又被后面的指定初始化<code>[1] = 29</code>初始化为29。</p><p>如果未指定元素大小会怎样?</p><pre><code class="cpp">int stuff[] = {1, [6] = 23};//会发生什么?int staff[] = {1, [6] = 4, 9, 10}; //会发生什么?</code></pre><p>编译器会把数组的大小设置为足够装得下初始化的值。所以，<code>stuff</code>数组有7个元素，编号为0~6；<code>staff</code>数组的元素比<code>stuff</code>数组多两个(即有9个元素)。</p><p>以上就是指定初始化器的笔记。</p><p>参考摘抄：《C Primer Plus第六版》</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;code&gt;C99&lt;/code&gt;增加了一个新特性：&lt;code&gt;指定初始化器(designated initializer)&lt;/code&gt;。利用该特性可以初始化指定的数组元素，也可以初始化指定的结构体变量（往期笔记&lt;a href=&quot;http://mp.weixin.qq.c
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】操作位的技巧</title>
    <link href="https://zhengnianli.github.io/2019/02/15/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91%E6%93%8D%E4%BD%9C%E4%BD%8D%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    <id>https://zhengnianli.github.io/2019/02/15/【C语言笔记】操作位的技巧/</id>
    <published>2019-02-15T00:22:15.000Z</published>
    <updated>2019-06-17T14:29:29.275Z</updated>
    
    <content type="html"><![CDATA[<p>操作位有两种方法，一种是<code>位字段</code>，另一种是使用<code>按位运算符</code>。位字段的方法可查看往期笔记：<a href="http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA==&mid=100000859&idx=1&sn=2983364c6e02771d18bbf81223172610&chksm=7e0d6a9c497ae38a4328253daa4e67724dca77fdd7ac386e280367e3f8a3d9e283b4f1dd77ef#rd" target="_blank" rel="noopener">【C语言笔记】位域</a>。本文介绍使用按位运算符操作位的方法。下表为几种位操作符及其含义：</p><p><a href="https://imgchr.com/i/VH0Pit" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH0Pit.md.png" alt="VH0Pit.md.png"></a></p><h3 id="不改变其他位的值的状况下，对某几个位进行设值。"><a href="#不改变其他位的值的状况下，对某几个位进行设值。" class="headerlink" title="不改变其他位的值的状况下，对某几个位进行设值。"></a>不改变其他位的值的状况下，对某几个位进行设值。</h3><p>在<code>嵌入式编程</code>中，常常需要对一些寄存器进行配置，有的情况下需要改变一个字节中的某一位或者几位，但是又不想改变其它位原有的值，这时就可以使用按位运算符进行操作。下面进行举例说明，假如有一个8位的TEST寄存器：</p><p><a href="https://imgchr.com/i/VH0QJ0" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH0QJ0.md.png" alt="VH0QJ0.md.png"></a></p><p>当我们要设置第0位bit0的值为1时，可能会这样进行设置：</p><pre><code class="cpp">TEST = 0x01;</code></pre><p>但是，这样设置是不够准确的，因为这时候已经同时操作到了高7位：<code>bit1~bit7</code>，如果这高7位没有用到的话，这么设置没有什么影响；但是，如果这7位正在被使用，结果就不是我们想要的了。</p><p>在这种情况下，我们就可以借用<code>&amp;</code>和<code>|</code>进行配置。</p><p>对于二进制位操作来说，不管该位原来的值是0还是1，它跟0进行&amp;运算，得到的结果都是0，而跟1进行&amp;运算，将保持原来的值不变；不管该位原来的值是0还是1，它跟1进行|运算，得到的结果都是1，而跟0进行|运算，将保持原来的值不变。</p><p>所以，此时可以设置为：</p><pre><code class="cpp">TEST = TEST | 0x01;</code></pre><p>其意义为：<code>TEST寄存器</code>的高7位均不变，最低位变成1了。在实际编程中，常改写为：</p><pre><code class="cpp">TEST |= 0x01;</code></pre><p>这种写法可以一定程度上简化代码，是 C 语言常用的一种编程风格。</p><p>同样的，要给<code>TEST</code>的低4位清0，高4位保持不变，可以进行如下配置：</p><pre><code class="cpp">TEST &amp;= 0xF0;</code></pre><p>这个场景<code>嵌入式开发</code>中经常使用，方法就是先对需要设置的位用<code>&amp;</code>操作符进行清零操作，然后用|操作符设值。比如我要改变<code>GPIOA</code>的状态,可以先对寄存器的值进行<code>&amp;</code>清零操作：</p><pre><code class="cpp">GPIOA-&gt;CRL &amp;= 0XFFFFFF0F; //将第4-7位清0</code></pre><p>然后再与需要设置的值进行|或运算：</p><pre><code class="cpp">GPIOA-&gt;CRL |= 0X00000040; //设置相应位的值，不改变其他位的值</code></pre><p>移位操作提高代码的可读性。</p><p>移位操作在单片机开发中也非常重要，下面让我们看看固件库的<code>GPIO</code>初始化的函数里面的一行代码：</p><pre><code class="cpp">GPIOx-&gt;BSRR = (((uint32_t)0x01) &lt;&lt; pinpos);</code></pre><p>这个操作就是将<code>BSRR</code>寄存器的第<code>pinpos</code>位设置为<code>1</code>，为什么要通过左移而不是直接设置一个固定的值呢？其实，这是为了提高代码的可读性以及可重用性。这行代码可以很直观明了的知道，是将第<code>pinpos</code>位设置为<code>1</code>。如果你写成：</p><pre><code class="cpp">GPIOx-&gt;BSRR = 0x0030;</code></pre><p>这样的代码就不好看也不好重用了。<br>类似这样的代码很多:</p><pre><code class="cpp">GPIOA-&gt;ODR |= 1 &lt;&lt; 5; //PA.5输出高,不改变其他位</code></pre><p>这样我们一目了然，5告诉我们是第5位也就是第6个端口，1告诉我们是设置为1了。</p><h3 id="取反操作使用技巧"><a href="#取反操作使用技巧" class="headerlink" title="~取反操作使用技巧"></a>~取反操作使用技巧</h3><p><code>SR寄存器</code>的每一位都代表一个状态，某个时刻我们希望去设置某一位的值为0，同时其他位都保留为1，简单的作法是直接给寄存器设置一个值：</p><pre><code class="cpp">TIMx-&gt;SR = 0xFFF7；</code></pre><p>这样的作法设置第3位为0，但是这样的作法同样不好看，并且可读性很差。看看库函数代码中怎样使用的：</p><pre><code class="cpp">TIMx-&gt;SR = (uint16_t)~TIM_FLAG;</code></pre><p>而TIM_FLAG 是通过宏定义定义的值：</p><pre><code class="cpp">#define TIM_FLAG_Update  ((uint16_t)0x0001)#define TIM_FLAG_CC1     ((uint16_t)0x0002)#define TIM_FLAG_CC2     ((uint16_t)0x0004)#define TIM_FLAG_CC3     ((uint16_t)0x0008)#define TIM_FLAG_CC4     ((int16_t)0x0010)#define TIM_FLAG_COM     ((uint16_t)0x0020)#define TIM_FLAG_Trigger ((uint16_t)0x0040)#define TIM_FLAG_Break   ((uint16_t)0x0080)#define TIM_FLAG_CC1OF   ((uint16_t)0x0200)#define TIM_FLAG_CC2OF   ((uint16_t)0x0400)#define TIM_FLAG_CC3OF   ((uint16_t)0x0800)#define TIM_FLAG_CC4OF   ((uint16_t)0x1000)</code></pre><p>即设置<code>SR</code>第3位为0时可设置为：</p><pre><code class="cpp">TIMx-&gt;SR = (uint16_t)~TIM_FLAG_CC3;</code></pre><p>以上就是关于位操作在嵌入式编程中的一些技巧，如有错误，欢迎指出！</p><p>参考资料：</p><p>《STM32F1开发指南-库函数版本_V3.1 》</p><p>《手把手教你学51单片机》</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;操作位有两种方法，一种是&lt;code&gt;位字段&lt;/code&gt;，另一种是使用&lt;code&gt;按位运算符&lt;/code&gt;。位字段的方法可查看往期笔记：&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA==&amp;mid=1000008
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】位域</title>
    <link href="https://zhengnianli.github.io/2019/02/14/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91%E4%BD%8D%E5%9F%9F/"/>
    <id>https://zhengnianli.github.io/2019/02/14/【C语言笔记】位域/</id>
    <published>2019-02-14T00:22:15.000Z</published>
    <updated>2019-06-17T14:31:30.926Z</updated>
    
    <content type="html"><![CDATA[<h3 id="位域的概念"><a href="#位域的概念" class="headerlink" title="位域的概念"></a>位域的概念</h3><p>有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用 0 和 1 表示足以，也就是用一个二进位。正是基于这种考虑，C语言又提供了一种数据结构，叫做<code>位域</code>或<code>位段</code>。</p><p>位域是操控位的一种方法（操控位的另一种方法是使用按位运算符，按位运算符将在之后的笔记中做介绍）。</p><p>位域通过一个结构声明来建立：该结构声明为每个字段提供标签，并确定该字段的宽度。例如，下面的声明建立了个4个1位的字段：</p><pre><code class="cpp">struct {   unsigned int autfd:1;   unsigned int bldfc:1;   unsigned int undin:1;   unsigned int itals:1;}prnt;</code></pre><p>根据该声明， prnt包含4个1位的字段。现在，可以通过普通的结构成员运算符<code>.</code>单独给这些字段赋值：</p><pre><code class="cpp">prnt.itals = 0:prnt.undin = 1;</code></pre><p>由于每个字段恰好为1位，所以只能为其赋值<code>1或0</code>。变量<code>prnt</code>被储存在<code>int</code>大小的内存单元中，但是在本例中只使用了其中的4位。</p><p> <code>:</code>后面的数字用来限定成员变量占用的位数。位域的宽度不能超过它所依附的数据类型的长度。通俗地讲，成员变量都是有类型的，这个类型限制了成员变量的最大长度，<code>:</code>后面的数字不能超过这个长度。</p><p>如上述结构中<code>autfd、bldfc、undin、itals</code>后面的数字不能超过<code>unsigned int</code>的位数，即在<code>32bi</code>t环境中就是不能超过32。</p><p>位域的取值范围非常有限，数据稍微大些就会发生溢出，请看下面的例子：</p><pre><code class="cpp">#include &lt;stdio.h&gt;struct pack{ unsigned a:2;  // 取值范围为：0~3 unsigned b:4;   // 取值范围为：0~15 unsigned c:6;   // 取值范围为：0~63};int main(void){ struct pack pk1; struct pack pk2; // 给pk1各成员赋值并打印输出 pk1.a = 1; pk1.b = 10; pk1.c = 50; printf(&quot;%d, %d, %d\n&quot;, pk1.a, pk1.b, pk1.c); // 给pk2各成员赋值并打印输出 pk2.a = 5; pk2.b = 20; pk2.c = 66; printf(&quot;%d, %d, %d\n&quot;, pk2.a, pk2.b, pk2.c); return 0;}</code></pre><p>程序输出结果为：</p><pre><code class="cpp">pk1.a = 1, pk1.a = 10, pk1.c = 5pk2.a = 1, pk2.b = 4, pk2.c = 2</code></pre><p>显然，结构体变量<code>pk1</code>的各成员都没有超出限定的位数，能够正常输出。而结构体变量<code>pk2</code>的各成员超出了限定的位数，并发生了<code>上溢</code>（溢出中的一种），关于溢出的概念可查看往期笔记：<a href="http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA==&mid=100000812&idx=1&sn=b8435d0429c74c6e4902b3e9e553de40&chksm=7e0d6aeb497ae3fd555711981b9fdb295058d8fcf4b47ad0850c1c68faa2ba9ad1fef9eaae14#rd" target="_blank" rel="noopener">【C语言笔记】整数溢出</a></p><p>C语言标准规定，只有有限的几种数据类型可以用于位域。在<code>ANSI C</code> 中，这几种数据类型是<code>signed int</code>和<code>unsigned int</code>；到了<code>C99、C11</code>新增了<code>_Bool</code>的位字段。关于C语言的几套标准可查看往期笔记：<a href="http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA==&mid=100000596&idx=1&sn=67dc88459a36f138cf98ce8d75469dfa&chksm=7e0d6d93497ae485a211f47eff1e92f3efed78d51ebe15cbb3ca101f5f8053584ce57c9cb5e6#rd" target="_blank" rel="noopener">【C语言笔记】什么是ANSI C标准？</a></p><h3 id="位域的存储"><a href="#位域的存储" class="headerlink" title="位域的存储"></a>位域的存储</h3><p>位域的存储同样遵循结构体内存对齐的规则，关于结构体内存对齐的问题可查看往期笔记：<a href="http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA==&mid=100000273&idx=1&sn=2acdd7fcfcdceec8cc34e3b8fb68a2d5&chksm=7e0d6cd6497ae5c0dbdd46e3ac865de3d938dba5fb9f6da955542224662fc8831693e4ef9c32#rd" target="_blank" rel="noopener">【C语言笔记】C语言结构体内存对齐问题</a></p><p>看一个例子：</p><pre><code class="cpp">#include &lt;stdio.h&gt;struct pack{ unsigned a:2;   unsigned b:4;    unsigned c:6;   };int main(void){ printf(&quot;sizeof(struct pack) = %d&quot;, sizeof(struct pack)); return 0;}</code></pre><p>程序输出结果为：</p><pre><code class="cpp">sizeof(struct pack) = 4</code></pre><p>这是因为，a、b、c成员所占的位长之和在一个存储单元（此处为unsigned类型所占的字节数）内，即4个字节内，所以struct pack类型的变量所占的字节长度为4个字节（实际a、b、c一共占用12bit,还有20bit空间为保留的空白）。</p><p>可能有人有疑问，此处a、b、c加起来一共才12bit，两个字节都不到，那么只需要，2个字节不就好了吗。这就是因为内存对齐搞的鬼，此处要将内存对齐到 4 个字节（unsigned类型所占的字节数），以便提高存取效率。</p><p>假如把该结构声明改为：</p><pre><code class="cpp">struct pack{ unsigned a:12;   unsigned b:24;    unsigned c:6;   };</code></pre><p>那么，输出结构应该为什么呢？</p><p>输出结果为：</p><pre><code class="cpp">sizeof(struct pack) = 8</code></pre><p>因为此时a成员单独占一个内存单元（4字节），b、c成员紧挨着占下一个内存单元（4字节），所以结果为8字节，这也是因为内存对齐。a、b、c占用内存的示意图如：</p><p><a href="https://imgchr.com/i/VHBRuF" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHBRuF.md.png" alt="VHBRuF.md.png"></a></p><p>其中，空白部分为保留的空白填充内存。这里的空白内存是系统自动留出的，同时，我们也可以自己留出填充内存。如<code>无名位域</code>就可以用来作填充：</p><pre><code class="cpp">struct pack{unsigned a:12;  unsigned  :20;//该位域成员不能使用，用于填充unsigned c:6;   };</code></pre><p><code>无名位域一般用来作填充或者调整成员位置。</code>因为没有名称，无名位域不能使用。<br>上面的例子中，如果没有位宽为 20 的无名成员，a、c 将会挨着存储，<code>sizeof(struct pack)</code> 的结果为 4；有了这 20 位作为填充，a、c将分开存储，<code>sizeof(struct pack)</code>的结果为 8。</p><p>位域也是个很重要的知识点，如在<code>DSP2803X</code>的固件库的一些结构封装中普遍用到这样的写法：</p><p><a href="https://imgchr.com/i/VHBWB4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHBWB4.md.png" alt="VHBWB4.md.png"></a></p><p>以上就是关于位域的一些笔记，如有错误，欢迎指出！</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;位域的概念&quot;&gt;&lt;a href=&quot;#位域的概念&quot; class=&quot;headerlink&quot; title=&quot;位域的概念&quot;&gt;&lt;/a&gt;位域的概念&lt;/h3&gt;&lt;p&gt;有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用 0
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】结构体</title>
    <link href="https://zhengnianli.github.io/2019/01/22/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>https://zhengnianli.github.io/2019/01/22/【C语言笔记】结构体/</id>
    <published>2019-01-22T00:22:15.000Z</published>
    <updated>2019-06-17T15:01:48.618Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道C语言中变量的类型决定了变量存储占用的空间。当我们要使用一个变量保存年龄时可以将其声明为<code>int</code>类型，当我们要使用一个变量保存某一科目的考试成绩时可以将其声明为<code>float</code>。</p><p>那么，当我们要做一个学生信息管理系统时，需要保存学生的姓名、学号、年龄等信息，该怎么做呢？</p><p>如当要保存三个学生的信息时，</p><p>方法一是：</p><pre><code class="c">char *name1,*name2,*name3;  // 三个学生的姓名int num1,num2,num3;         // 三个学生的学号int age1,age2,age3;         // 三个学生的年龄</code></pre><p>方法二是：</p><pre><code class="c">// 创建结构体模板struct student{  char *name;  // 学生名字  int num;     // 学生学号  int age;     // 学生年龄};// 使用该结构体模板创建三个变量stu1, stu2, stu3struct student stu1, stu2, stu3;</code></pre><p>显然，方法二跟更清晰，因为它把<code>name、num、age</code>都集成在一个模板，要用的时候只要套用模板进行创建即可。这就是<code>结构体</code>。</p><h3 id="什么是结构体"><a href="#什么是结构体" class="headerlink" title="什么是结构体"></a>什么是结构体</h3><p><code>结构体(struct)</code>是由一系列具有相同类型或不同类型的数据项构成的数据集合，这些数据项称为结构体的成员。如上面的<code>student</code>结构体包含三个成员，分别是<code>name、num、age</code>。</p><p>结构体是C语言中的一种构造类型。C语言的数据类型如下图：</p><p><a href="https://imgchr.com/i/VHCDJg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHCDJg.md.png" alt="VHCDJg.md.png"></a></p><h3 id="结构体变量的定义方法"><a href="#结构体变量的定义方法" class="headerlink" title="结构体变量的定义方法"></a>结构体变量的定义方法</h3><p>####方法一</p><pre><code class="c">// 创建结构体模板struct studentstruct student{char *name;  // 学生名字int num;     // 学生学号int age;     // 学生年龄};// 使用该结构体模板创建三个变量stu1, stu2, stu3struct student stu1, stu2, stu3;</code></pre><p>此处，student是结构体名，该名字是由任意定义的，但是尽量起个有意义的名称。其相当于一个模板，可以使用这个模板去定义变量<code>stu1，stu2，stu3</code>。定义的时候不要忘了<code>struct</code>。</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><pre><code class="c">// 定义三个结构体变量stu1, stu2, stu3struct{char *name;  // 学生名字int num;     // 学生学号int age;     // 学生年龄}stu1, stu2, stu3;</code></pre><p>相对于方法一，此处省略了结构体名。虽然更简洁了，但是因为没有了名字，后面就不能用该结构定义新的变量。</p><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><pre><code class="c">// 给结构体模板struct student重新命名为studenttypedef struct student{char *name;  // 学生名字int num;     // 学生学号int age;     // 学生年龄}student;// 使用student创建三个结构体变量stu1, stu2, stu3student stu1, stu2, stu3;</code></pre><p>此处使用<code>typedef</code>为结构体模板<code>struct student</code>定义一个别名<code>student</code>，关于<code>typedef</code>的介绍移步至往期笔记：<a href="https://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA==&mid=2247483836&idx=3&sn=2495cd250834605b8e92b5c6c1a33a95&chksm=fe0d6f7bc97ae66db2f0059322a442c661a396beb4450fb0c6427a288b0e010b5af3be134726&scene=21#wechat_redirect" target="_blank" rel="noopener">【C语言笔记】#define与typedef的区别？</a>进行查看。使用<code>typedef</code>给结构体创建一个别名，这在实际编程用使用非常广泛，如<code>STM32</code>单片机固件库中，使用得很多，如下图：</p><p><a href="https://imgchr.com/i/VHPZtS" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHPZtS.md.png" alt="VHPZtS.md.png"></a></p><h3 id="初始化结构"><a href="#初始化结构" class="headerlink" title="初始化结构"></a>初始化结构</h3><p>初始化变量和数组如下：</p><pre><code class="c">int count = 0;int arr[7] = {0,1,2,3,4,5,6};</code></pre><p>结构体变量是否也可以这样初始化？是的，可以。与初始化数组的语法类似：</p><pre><code class="c">struct student stu1 = {  &quot;ZhengNianJun&quot;, // 名字：正念君  520,            // 学号：520  23              // 年龄：23};</code></pre><p>简而言之，我们使用在一对花括号中括起来的初始化列表进行初始化，各初始化项用逗号分隔。</p><p>为了让初始化项与结构中各成员的关联更加明显，我们让每个成员的初始化项独占一行。这样做只是为了提高代码的可读性，对编译器而言，只需要用逗号分隔各成员的初始化项即可。</p><p><code>C99</code>和<code>C11</code>为结构提供了<code>指定初始化器（designated initializer）</code>。其初始化器使用点运算符和成员名。例如，只初始化<code>student</code>结构中的<code>name</code>成员，可以这样做：</p><pre><code class="c">struct student stu1 ={   .name = &quot;ZhengNianJun&quot;};</code></pre><p>也可以按照任意顺序使用指定初始化器：</p><pre><code class="c">struct student stu1 ={   .age = 24,   .num = 520,   .name = &quot;ZhengNianJun&quot;};</code></pre><p>另外，对特定成员的最后一次赋值才是它实际获得的值。例如，考虑如下代码：</p><pre><code class="c">struct student stu1 ={  .num = 520,  .name = &quot;ZhengNianJun&quot;，   1314};</code></pre><p>此时，赋给<code>num</code>的值应该是<code>1314</code>，因为它在结构声明中紧跟在<code>name</code>成员之后。新值<code>1314</code>取代了之前的<code>520</code>。</p><p>指定初始化器在实际编程中也很常用到。如在<code>linux2.6.32.2</code>源码的<code>usb</code>驱动中（路径为：<code>linux-2.6.32.2\drivers\usb\storage\usb.c</code>），有如下代码：</p><p><a href="https://imgchr.com/i/VHPD76" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHPD76.md.png" alt="VHPD76.md.png"></a></p><h3 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h3><p>结构体成员的访问需要借助结构体成员运算符——点（.）。如：</p><pre><code class="c">student stu1; // 定义一个结构体变量stu1stu1.name = &quot;ZhengNianJun&quot;; // 给stu1的成员name赋值stu1.num = 520;             // 给stu1的成员num赋值stu1.age = 23;              // 给stu1的成员age赋值</code></pre><p>实例</p><pre><code class="c">#include &lt;stdio.h&gt;typedef struct student{ char *name;  // 学生名字 int num;     // 学生学号 int age;     // 学生年龄}student;int main(void){ student stu1;  // 定义一个结构体变量stu1 /* 给结构体变量stu1的成员进行赋值 */ stu1.name = &quot;ZhengNianJun&quot;; stu1.num = 520; stu1.age = 23; printf(&quot;\n============================================\n&quot;); printf(&quot;My name is %s\n&quot;, stu1.name); printf(&quot;My num is %d\n&quot;, stu1.num); printf(&quot;My age is %d\n&quot;, stu1.age); printf(&quot;欢迎关注正念君编程学习笔记！\n&quot;, stu1.age); printf(&quot;============================================\n&quot;); return 0;}</code></pre><p>程序运行结果为：</p><p><a href="https://imgchr.com/i/VHPq3Q" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHPq3Q.md.png" alt="VHPq3Q.md.png"></a></p><p>结构体是一块很重要的内容，用得很多。关于结构体的内存对齐可查看往期笔记：<a href="https://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA==&mid=2247483922&idx=1&sn=e0d24baca5bd0d0accabd2b864479a67&chksm=fe0d6cd5c97ae5c305b52d3e3267f89077af1d948471eec064562c7bd09677d11da7da8aae41&scene=21#wechat_redirect" target="_blank" rel="noopener">【C语言笔记】C语言结构体内存对齐问题</a></p><p>以上就是关于结构体的一些笔记，如有错误欢迎指出。谢谢！</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们都知道C语言中变量的类型决定了变量存储占用的空间。当我们要使用一个变量保存年龄时可以将其声明为&lt;code&gt;int&lt;/code&gt;类型，当我们要使用一个变量保存某一科目的考试成绩时可以将其声明为&lt;code&gt;float&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那么，当我们要做一个学生信
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】枚举</title>
    <link href="https://zhengnianli.github.io/2019/01/15/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91%E6%9E%9A%E4%B8%BE/"/>
    <id>https://zhengnianli.github.io/2019/01/15/【C语言笔记】枚举/</id>
    <published>2019-01-15T00:22:15.000Z</published>
    <updated>2019-06-17T14:36:21.677Z</updated>
    
    <content type="html"><![CDATA[<p>首先，提一下宏定义<code>#define</code>，其一般形式为：</p><pre><code class="c">#define 宏名 字符串</code></pre><p>这个知识点很重要，到处能用得到。其可以与typedef来进行类比进行理解（可查看<a href="http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA==&mid=100000185&idx=3&sn=45449023129f96bf6966512ec44e7e10&chksm=7e0d6f7e497ae6681f2ec2d4ac51a56757d5e7787be9abfac943c548f2a43dffe3cdf2dab19b#rd" target="_blank" rel="noopener">【C语言笔记】define与typedef的区别？</a>）。除此之外，其还可以与<code>enum</code>进行类比。</p><h3 id="什么是枚举"><a href="#什么是枚举" class="headerlink" title="什么是枚举"></a>什么是枚举</h3><p>从字面理解，就是一一列举的意思。很多时候，有一些数据的取值有限的，这时候可以把这些可能的结果列出来，并赋予新的名字，这样有助于提高代码的可读性。例如，一个星期有7天，一年有12个月，期末考试科目有6个科目等情况，完全可以一一列举出来。</p><p>当我们要为整数定义一些别名（例如定义为星期数）的时候，可以使用宏定义，如：</p><pre><code class="cpp">#define MON  1#define TUE  2#define WED  3#define THU  4#define FRI  5#define SAT  6#define SUN  7</code></pre><p>此时，我们可以使用枚举来达到同样的效果，如：</p><pre><code class="cpp">enum DAY{     MON=1, TUE, WED, THU, FRI, SAT, SUN};</code></pre><p>其中，<code>enum</code>是关键字，是必须的。<code>DAY</code>是枚举名，可有可无，这个名字是自己定义的；<code>MON=1, TUE, WED, THU, FRI, SAT, SUN</code>是枚举成员。</p><p>枚举成员的值是根据前一个成员的值递增1，即上面枚举定义等价于：</p><pre><code class="c">enum DAY{    MON=1, TUE=2, WED=3, THU=4, FRI=5, SAT=6, SUN=7};</code></pre><p>若上述定义中第一个成员<code>MON</code>不赋值的话，那么其默认为<code>0</code>。</p><p>若其他成员赋了初值，也是遵循“枚举成员的值是根据前一个成员的值递增1”这一规则，如：</p><pre><code class="cpp">enum DAY{   A,B,C=100,D,F=200,G };</code></pre><p>此处</p><pre><code class="cpp">A=0B=1C=100D=101F=200G=201</code></pre><h3 id="枚举类型变量的定义方法"><a href="#枚举类型变量的定义方法" class="headerlink" title="枚举类型变量的定义方法"></a>枚举类型变量的定义方法</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><pre><code class="cpp">enum DAY{    MON=1, TUE, WED, THU, FRI, SAT, SUN};enum DAY good_day, bad_day;</code></pre><p>此处，<code>DAY</code>是枚举名，相当于一个模板，可以使用这个模板去定义变量<code>good_day</code>，<code>bad_day</code>，定义的时候不要忘了<code>enum</code>。</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><pre><code class="cpp">enum{   MON=1, TUE, WED, THU, FRI, SAT, SUN}good_day, bad_day;</code></pre><p>相对于方法一，此处省略了枚举名。虽然更简洁了，但是因为没有了名字，后面就不能用该枚举定义新的变量。</p><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><pre><code class="cpp">typedef enum DAY{   MON=1, TUE, WED, THU, FRI, SAT, SUN}DAY;DAY good_day, bad_day;</code></pre><p>此处使用<code>typedef</code>为枚举定义一个别名，这个别名为<code>DAY</code>，关于<code>typedef</code>的介绍可点击文首的链接进行查看。</p><h3 id="程序实例"><a href="#程序实例" class="headerlink" title="程序实例"></a>程序实例</h3><p>编译环境为 : <code>gcc 6.3.0</code></p><pre><code class="cpp">#include &lt;stdio.h&gt;typedef enum DAY{  MON=1, TUE, WED, THU, FRI, SAT, SUN}DAY;int main(void){ DAY good_day; printf(&quot;你觉得一周中哪一天最美好？\n&quot;); scanf(&quot;%d&quot;, &amp;good_day); printf(&quot;我比较喜欢&quot;); switch(good_day) { case MON: printf(&quot;星期一&quot;); break; case TUE: printf(&quot;星期二&quot;); break; case WED: printf(&quot;星期三&quot;); break; case THU: printf(&quot;星期四&quot;); break; case FRI: printf(&quot;星期五&quot;); break; case SAT: printf(&quot;星期六&quot;); break; case SUN: printf(&quot;星期日&quot;); break; default:  printf(&quot;Error!&quot;); break; } return 0;}</code></pre><p>程序运行结果：</p><p><a href="https://imgchr.com/i/VH8JUS" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH8JUS.md.png" alt="VH8JUS.md.png"></a></p><h3 id="枚举变量占用的字节数？"><a href="#枚举变量占用的字节数？" class="headerlink" title="枚举变量占用的字节数？"></a>枚举变量占用的字节数？</h3><p>实测程序：</p><pre><code class="cpp">#include &lt;stdio.h&gt;typedef enum DAY{  MON=1, TUE, WED, THU, FRI, SAT, SUN}DAY;int main(void){ DAY good_day; printf(&quot;sizeof(DAY) = %d\n&quot;,sizeof(DAY)); printf(&quot;sizeof(good_day) = %d\n&quot;,sizeof(good_day)); printf(&quot;sizeof(int) = %d\n&quot;,sizeof(int)); return 0;}</code></pre><p>运行结果：</p><p><a href="https://imgchr.com/i/VH8U3j" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH8U3j.md.png" alt="VH8U3j.md.png"></a></p><p>从该程序运行结果也可看出，枚举类型变量需要存放的是一个整数，它的长度和int的长度相同。</p><p>以上就是关于枚举类型enum的一些笔记，如有错误欢迎指出。</p><p>最后，分享两篇关于枚举的文章，都讲得很详细。</p><pre><code class="c">https://www.cnblogs.com/JCSU/articles/1299051.htmlhttp://c.biancheng.net/cpp/html/99.html</code></pre><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，提一下宏定义&lt;code&gt;#define&lt;/code&gt;，其一般形式为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#define 宏名 字符串&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个知识点很重要，到处能用得到。其可以与typedef来进行类比进行理解（可查看&lt;a 
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】整数溢出问题</title>
    <link href="https://zhengnianli.github.io/2019/01/10/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98/"/>
    <id>https://zhengnianli.github.io/2019/01/10/【C语言笔记】整数溢出问题/</id>
    <published>2019-01-10T00:22:15.000Z</published>
    <updated>2019-06-17T14:59:50.641Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>整数溢出是一种未定义的行为，当产生溢出行为时，系统并不会通知用户，所以应当多加小心。如下是整数溢出的一个案例：</p><p><a href="https://imgchr.com/i/VHnOiR" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHnOiR.md.png" alt="VHnOiR.md.png"></a></p><p>SMT爆出的美图BEC代币出现的安全漏洞—整数溢出，该漏洞代理的直接经济损失高达上亿元人民币，间接产生的负面影响目前无法估量。</p><h3 id="什么是整数溢出？"><a href="#什么是整数溢出？" class="headerlink" title="什么是整数溢出？"></a>什么是整数溢出？</h3><p>计算机语言中整数类型都有一个取值范围，两个整数进行运算时，若其结果大于最大值（<code>上溢</code>）或者小于最小值（<code>下溢</code>）就是溢出。</p><p>假如最大值为 <code>a</code> ，在最大值和最小值之间如果发生以下计算：</p><blockquote><p>a+1=0或0-1=a</p></blockquote><p>此时就会发生溢出，其中<code>a+1=0</code>会发生上溢，<code>0-1=a</code>会发生下溢。</p><h3 id="程序实例"><a href="#程序实例" class="headerlink" title="程序实例"></a>程序实例</h3><p>示例（在32bit环境中编译）</p><pre><code class="c">// 整数溢出例子#include &lt;stdio.h&gt;int main(void){ short i = 32767; unsigned short j = 65535; unsigned short k = 0; // 上溢例子 printf(&quot;%hd %hd %hd\n&quot;, i, i+1, i+2);   // 上溢例子 printf(&quot;%hu %hu %hu\n&quot;, j, j+1, j+2);  // 下溢例子 printf(&quot;%hu %hu %hu\n&quot;, k, k-1, k-2);  return 0;}</code></pre><p>程序运行结果为：</p><p><a href="https://imgchr.com/i/VHnzQK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHnzQK.md.png" alt="VHnzQK.md.png"></a></p><p>在32bit环境中，short（占两个字节）的范围为：</p><pre><code class="c">-32768~32767</code></pre><p>unsigned short的范围为：</p><pre><code>0~65535</code></pre><p>所以<code>short</code>类型的<code>i=32767</code>加1、加2时会产生上溢。<code>unsigned short</code>类型的<code>j=65535</code>加1、加2时会产生上溢。<code>unsigned short</code>类型的k=0减1、减2时会产生下溢。</p><p>（ps：可以使用程序来查看整数数据类型的范围，具体可移步至<a href="http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA==&mid=100000603&idx=1&sn=b4c71c14e56cf5a68d7700c391c39cdc&chksm=7e0d6d9c497ae48a53929fca159525ebd10b4f2e5e0f08d996c15ce2702a4506252833582ab0#rd" target="_blank" rel="noopener">【C语言笔记】如何查看数据类型范围？</a>进行查看）</p><p>以上就是关于整数溢出的笔记分享，如有错误欢迎指出！</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;整数溢出是一种未定义的行为，当产生溢出行为时，系统并不会通知用户，所以应当多加小心。如下是整数溢出的一个案例：&lt;/p&gt;
&lt;p&gt;&lt;a href
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】函数指针作为函数的参数</title>
    <link href="https://zhengnianli.github.io/2019/01/04/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/"/>
    <id>https://zhengnianli.github.io/2019/01/04/【C语言笔记】函数指针作为函数的参数/</id>
    <published>2019-01-04T00:22:15.000Z</published>
    <updated>2019-06-17T14:57:26.434Z</updated>
    
    <content type="html"><![CDATA[<p>函数指针有两种常用的用法，一种是作为结构体成员，关于函数指针作为结构体成员的用法可移步至上一篇<a href="http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA==&mid=100000771&idx=1&sn=179739c83e8460c04d5aa749b63d3345&chksm=7e0d6ac4497ae3d2e9a2c049637ffb770d81b7992ed2bf06e28b127414ba0aa21b2653890a8c#rd" target="_blank" rel="noopener">【C语言笔记】函数指针作为结构体成员</a>进行查看。另一种是函数指针作为函数的参数。这一篇分享的是函数指针作为函数的参数。</p><h3 id="函数指针作为函数的参数"><a href="#函数指针作为函数的参数" class="headerlink" title="函数指针作为函数的参数"></a>函数指针作为函数的参数</h3><p>函数指针可以作为一个参数传递给另一个函数。这时函数指针的使用就像普通的常量和变量一样。当函数指针作为参数传递的时候，这时接收参数传递的函数通常需要根据这个指针调用这个函数。作为参数传递的函数指针通常表示<code>回调函数（Callback Functions）</code>。</p><h4 id="什么是回调函数？"><a href="#什么是回调函数？" class="headerlink" title="什么是回调函数？"></a>什么是回调函数？</h4><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。</p><h4 id="回调函数在实际中有什么作用？"><a href="#回调函数在实际中有什么作用？" class="headerlink" title="回调函数在实际中有什么作用？"></a>回调函数在实际中有什么作用？</h4><p>先假设有这样一种情况：我们要编写一个库，它提供了某些排序算法的实现（如冒泡排序、快速排序等等），为了能让库更加通用，不想在函数中嵌入排序逻辑，而让使用者来实现相应的逻辑；或者，能让库可用于多种数据类型（int、float、string），此时，该怎么办呢？可以使用函数指针，并进行回调。</p><p>例如，在C语言的通用工具库stdlib.h中，有如下一个函数原型：</p><pre><code class="c">void qsort(void *, size_t, size_t, int (comp*)(const void *, const void *))</code></pre><p>这是在C通用工具库中声明的一个快速排序算法函数，其可以用来排序int类型、float类型以及字符串数据，可以按从小到大的顺序也可以按从大到小的顺序排序。其关键在于函数指针comp指向的函数的具体实现。</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>上一节我们使用函数指针作为结构体成员来实现四则运算，这里一节我们稍微修改一下代码，使用函数指针作为函数参数来实现四则运算。</p><p>设计如下函数：</p><pre><code class="c">int calculate(int a, int b, fun_t operation){ int result; result = operation(a, b); // 运算 return result;}</code></pre><p>其中，fun_t是一个函数指针，其定义为：</p><pre><code class="c">typedef int (*fun_t)(int, int);</code></pre><p>该函数指针<code>fun_t</code>指向一个带两个<code>int</code>类型的形参、<code>int</code>类型的返回值的函数。使用关键字<code>typedef</code>对<code>int (*)(int, int)</code>进行重命名（封装）为<code>fun_t</code>。关于typedef与define的区别可查看往期笔记：<a href="http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA==&mid=100000169&idx=2&sn=f9eb4d80e50404c0ce3804359a84af7e&chksm=7e0d6f6e497ae678e7cb45d9ed28fbfb2d30b3cd7af52db1618241e575ff6f8ae8c1717ba128#rd" target="_blank" rel="noopener">【C语言笔记】#define与typedef的区别？</a></p><p>根据函数指针变量<code>operation</code>指向不同的运算函数可实现加法运算、减法运算、乘法运算、除法运算。</p><p>主函数代码如下：</p><pre><code class="c">int main(void){ int result; int a = 192, b = 48; /* 两个数相加的操作 */ result = calculate(a, b, add2); printf(&quot;加法运算: %d+%d = %d\n&quot;,a, b, result); /* 两个数相减的操作 */ result = calculate(a, b, sub2); printf(&quot;减法运算: %d-%d = %d\n&quot;,a, b, result); /* 两个数相乘的操作 */ result = calculate(a, b, mul2); printf(&quot;乘法运算: %d*%d = %d\n&quot;,a, b, result); /* 两个数相除的操作 */ result = calculate(a, b, div2); printf(&quot;除法运算: %d/%d = %d\n&quot;,a, b, result); return 0;}</code></pre><p>实现运算的4个函数很简单，如下：</p><pre><code class="c">int add2(int a, int b){ return a+b;}int sub2(int a, int b){ return a-b;}int mul2(int a, int b){ return a*b;}int div2(int a, int b){ return a/b;}</code></pre><p>程序运行结果为：</p><p><a href="https://imgchr.com/i/VHQH6x" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHQH6x.md.png" alt="VHQH6x.md.png"></a></p><p>以上就是关于函数指针作为函数参数的笔记，如有错误欢迎指出！</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;函数指针有两种常用的用法，一种是作为结构体成员，关于函数指针作为结构体成员的用法可移步至上一篇&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA==&amp;mid=100000771&amp;idx=1&amp;sn=179739c83
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】函数指针作为结构体成员</title>
    <link href="https://zhengnianli.github.io/2019/01/03/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98/"/>
    <id>https://zhengnianli.github.io/2019/01/03/【C语言笔记】函数指针作为结构体成员/</id>
    <published>2019-01-03T00:22:15.000Z</published>
    <updated>2019-06-17T14:52:28.523Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数指针在C语言中的意义"><a href="#函数指针在C语言中的意义" class="headerlink" title="函数指针在C语言中的意义"></a>函数指针在C语言中的意义</h3><p>在C语言程序中，数据结构和算法是两个基本的元素。C语言的基本数据类型、结构体、数组和联合体是数据结构的代表；C语言中的函数则是算法的代表。只有将数据结构和算法有机结合才能构成具有一定功能的程序。</p><h3 id="函数指针的应用"><a href="#函数指针的应用" class="headerlink" title="函数指针的应用"></a>函数指针的应用</h3><p>函数指针在嵌入式中的应用非常广泛，常常把函数指针作为结构体的成员、作为函数的参数等。如在物联网操作系统RT-Thread内核源码中，有如下代码：</p><h4 id="1、函数指针作为结构体成员"><a href="#1、函数指针作为结构体成员" class="headerlink" title="1、函数指针作为结构体成员"></a>1、函数指针作为结构体成员</h4><p><a href="https://imgchr.com/i/VHlag1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHlag1.md.png" alt="VHlag1.md.png"></a></p><h4 id="2、函数指针作为函数的参数"><a href="#2、函数指针作为函数的参数" class="headerlink" title="2、函数指针作为函数的参数"></a>2、函数指针作为函数的参数</h4><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>建立一个结构体，用于四则运算（根据函数指针的指向可以选择加法运算、减法运算、乘法运算、除法运算），如</p><pre><code class="c">typedef int (*fun_t)(int, int);    // 包含了数据和算法的结构体struct Source{ int a;        // 数据a int b;        // 数据b fun_t operation;  // 算法operation};</code></pre><p>主函数内可以进行如下操作：</p><pre><code class="c">struct Source data;int result;data.a = 200;data.b = 100;/* 两个数相加的操作 */data.operation = add2;  result = data.operation(data.a, data.b);printf(&quot;加法运算: %d+%d = %d\n&quot;,data.a, data.b, result);</code></pre><p>函数指针<code>data.operation</code>指向加法函数<code>add2</code>，则调用<code>data.operation</code>就可以进行加法运算。同理，有：</p><pre><code class="c">/* 两个数相减的操作 */data.operation = sub2;result = data.operation(data.a, data.b);printf(&quot;减法运算: %d-%d = %d\n&quot;,data.a, data.b, result);/* 两个数相乘的操作 */data.operation = mul2;result = data.operation(data.a, data.b);printf(&quot;乘法运算: %d*%d = %d\n&quot;,data.a, data.b, result);/* 两个数相除的操作 */data.operation = div2;result = data.operation(data.a, data.b);printf(&quot;除法运算: %d/%d = %d\n&quot;,data.a, data.b, result);</code></pre><p>运行结果：</p><p><a href="https://imgchr.com/i/VHl4Df" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHl4Df.md.png" alt="VHl4Df.md.png"></a></p><p>以上就是函数指针作为结构体成员的笔记，如有错误欢迎指出！</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数指针在C语言中的意义&quot;&gt;&lt;a href=&quot;#函数指针在C语言中的意义&quot; class=&quot;headerlink&quot; title=&quot;函数指针在C语言中的意义&quot;&gt;&lt;/a&gt;函数指针在C语言中的意义&lt;/h3&gt;&lt;p&gt;在C语言程序中，数据结构和算法是两个基本的元素。C语言的基本
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】你的黑窗口闪退？</title>
    <link href="https://zhengnianli.github.io/2018/12/24/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91%E4%BD%A0%E7%9A%84%E9%BB%91%E7%AA%97%E5%8F%A3%E9%97%AA%E9%80%80%EF%BC%9F/"/>
    <id>https://zhengnianli.github.io/2018/12/24/【C语言笔记】你的黑窗口闪退？/</id>
    <published>2018-12-24T00:22:15.000Z</published>
    <updated>2019-06-18T04:12:29.400Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇中写到了Windows下体验Linux环境，其中的测试代码简单的打印一句话，如：</p><p><a href="https://imgchr.com/i/V73PHO" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V73PHO.md.png" alt="V73PHO.md.png"></a></p><p>编译后得到<code>test.exe</code>，运行得到如下结果：</p><p><a href="https://imgchr.com/i/V73uKP" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V73uKP.md.png" alt="V73uKP.md.png"></a></p><p>在命令行下运行可以输出结果，但是在文件夹下，双击运行test1.exe却发现黑窗口一闪而过：</p><p><a href="https://imgchr.com/i/V73GCj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V73GCj.md.png" alt="V73GCj.md.png"></a></p><p>怎么让黑窗口暂停呢？这里有两种方法：</p><p>【方法一】在程序的最后添加一行代码：</p><pre><code class="c">system(&quot;pause&quot;);</code></pre><p>同时，添加头文件<code>stdlib.h</code>，即</p><p><a href="https://imgchr.com/i/V73arV" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V73arV.md.png" alt="V73arV.md.png"></a></p><p><code>system</code>是C函数库<code>stdlib.h</code>中的一个函数，函数原型为：</p><pre><code class="c">int system (const char * command)；</code></pre><p>将命令<code>command</code>传给系统，其中<code>pause</code>命令的意思是让程序暂停一下，显示一个中文信息：<code>请按任意键继续. . .</code>，或者英文信息：<code>Press any key to continue . . .</code>。</p><p>编译，运行结果为：</p><p><a href="https://imgchr.com/i/V73sPJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V73sPJ.md.png" alt="V73sPJ.md.png"></a></p><p>有些<code>IDE（集成开发环境）</code>会自动输出<code>请按任意键继续. . .</code>这一句，有些没有，想让程序暂停一下就得手动添加<code>system(&quot;pause&quot;);</code>这一句代码。</p><p>【方法二】在程序的最后添加一行代码：</p><pre><code class="c">getchar();</code></pre><p>即：</p><p><a href="https://imgchr.com/i/V78SiQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V78SiQ.md.png" alt="V78SiQ.md.png"></a></p><p><code>getchar()</code>用于读取一次按键按下（读取字符）。当程序调用<code>getchar()</code>时，程序就等着用户按键。用户输入的字符被存放在键盘缓冲区中，直到用户按回车为止（回车字符也放在缓冲区中）。关于getchar()，可以查看往期笔记getchar()、getche()、getch()的区别？</p><p>编译，运行结果：</p><p><a href="https://imgchr.com/i/V78EZT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V78EZT.md.png" alt="V78EZT.md.png"></a></p><p>以上就是解决黑窗口闪退的两种方法，如有错误，欢迎指出！</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇中写到了Windows下体验Linux环境，其中的测试代码简单的打印一句话，如：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/V73PHO&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https:/
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】Windows下体验Linux环境</title>
    <link href="https://zhengnianli.github.io/2018/12/23/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91Windows%E4%B8%8B%E4%BD%93%E9%AA%8CLinux%E7%8E%AF%E5%A2%83/"/>
    <id>https://zhengnianli.github.io/2018/12/23/【C语言笔记】Windows下体验Linux环境/</id>
    <published>2018-12-23T00:22:15.000Z</published>
    <updated>2019-06-18T04:22:32.212Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>若要使用Linux环境，可以把Linux操作系统装在真机上，也可以把Linux操作系统安装在虚拟机上（如VMware）。本文介绍除了这两种方法之外的第三种可以使用Linux环境的方法，请往下看。</p><p>在Windows系统下可以使用集成开发环境（如Visual Studio、VC++、C-free等）编译C语言源代码文件，也可以使用命令行编译。</p><p>若要使用命令行编译C文件，就必须得安装C编译器，因为C编译器不是标准Windows软件包的一部分，因此需要从别处获取并安装。常用的有两种：一种是<code>MinGW</code>（之前已经分享过，可移步至MinGW进行查看）；另一种是<code>Cygwin</code>，本文着重介绍Cygwin。</p><h3 id="Cygwin简介"><a href="#Cygwin简介" class="headerlink" title="Cygwin简介"></a>Cygwin简介</h3><p><code>Cygwin</code>是一个在windows平台上运行的<code>类UNIX</code>模拟环境，是<code>cygnus solutions</code>公司开发的自由软件（该公司开发的著名工具还有<code>eCos</code>，不过现已被<code>Redhat</code>收购）。</p><p>它对于学习<code>UNIX/Linux</code>操作环境，或者从<code>UNIX</code>到<code>Windows</code>的应用程序移植，或者进行某些特殊的开发工作，尤其是使用<code>GNU</code>工具集在<code>Windows</code>上进行嵌入式系统开发，非常有用。随着嵌入式系统开发在国内日渐流行，越来越多的开发者对<code>Cygwin</code>产生了兴趣。</p><h3 id="Cygwin下载、安装"><a href="#Cygwin下载、安装" class="headerlink" title="Cygwin下载、安装"></a>Cygwin下载、安装</h3><p>1、下载链接</p><blockquote><p><a href="https://cygwin.com/install.html" target="_blank" rel="noopener">https://cygwin.com/install.html</a></p></blockquote><p>打开该网址，可以看到如下页面：</p><p><a href="https://imgchr.com/i/V7hayn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/V7hayn.md.png" alt="V7hayn.md.png"></a></p><p>根据自己的需求选择下载32bit或者64bit的Cygwin包。</p><p>2、安装</p><p>由上一步下载得到.exe结尾的软件，双击进行安装，一直点击下一步直至安装完成。安装的路径根据自己的需要进行选择。</p><h3 id="Cygwin的使用"><a href="#Cygwin的使用" class="headerlink" title="Cygwin的使用"></a>Cygwin的使用</h3><p>打开上一步安装的路径，如：</p><p><a href="https://imgchr.com/i/V7hBwV" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/V7hBwV.md.png" alt="V7hBwV.md.png"></a></p><p>双击<code>Cygwin.bat</code>文件即可打开Linux命令行。双击后得到如下界面：</p><p><a href="https://imgchr.com/i/V7hDoT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/V7hDoT.md.png" alt="V7hDoT.md.png"></a></p><p>这就是Linux命令行，然后就可以进行一些Linux练习啦。如：</p><p><a href="https://imgchr.com/i/V7h6W4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/V7h6W4.md.png" alt="V7h6W4.md.png"></a></p><p>进行如上操作后，就可以在<code>/c_test/test1/</code>路径下看到<code>test.c</code>文件啦（以上创建文件及文件夹的操作也可以直接在Windows下完成）。如：</p><p><a href="https://imgchr.com/i/V7vLeU" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/V7vLeU.md.png" alt="V7vLeU.md.png"></a></p><p>使用<code>notepad++</code>打开该<code>test1.c</code>输入如下代码并保存：</p><p><a href="https://imgchr.com/i/V7x3Tg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/V7x3Tg.md.png" alt="V7x3Tg.md.png"></a></p><p>然后在我们的Linux终端中进行编译：</p><p><a href="https://imgchr.com/i/V7xTtH" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/V7xTtH.md.png" alt="V7xTtH.md.png"></a></p><p>以上就是关于在windows下体验Linux的方法。</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;若要使用Linux环境，可以把Linux操作系统装在真机上，也可以把Linux操作系统安装在虚拟机上（如VMware）。本文介绍除了这两种方
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】windows命令行下编译C程序</title>
    <link href="https://zhengnianli.github.io/2018/12/23/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E7%BC%96%E8%AF%91C%E7%A8%8B%E5%BA%8F/"/>
    <id>https://zhengnianli.github.io/2018/12/23/【C语言笔记】windows命令行下编译C程序/</id>
    <published>2018-12-23T00:22:15.000Z</published>
    <updated>2019-06-18T04:22:14.517Z</updated>
    
    <content type="html"><![CDATA[<p>有关注我的朋友可能会知道我的C开发环境是：<code>Notepad++</code>与<code>MinGW</code>相结合，即用<code>Notepad++</code>写代码，用<code>MinGW</code>这个工具包中的<code>gcc编译器</code>进行编译。如：</p><p>在Notepad++里写代码：</p><p><a href="https://imgchr.com/i/VH1SVU" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH1SVU.md.png" alt="VH1SVU.md.png"></a></p><p>在黑窗口下编译及运行代码：</p><p><a href="https://imgchr.com/i/VH1954" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH1954.md.png" alt="VH1954.md.png"></a></p><p>此处，编译命令为:</p><pre><code class="c">gcc hello.c</code></pre><p>生成的可执行文件默认为<code>a.exe</code>，输入<code>a.exe</code>即可运行该可执行程序。同样，也可添加<code>-o</code>参数给<code>a.exe</code>进行重命名，如把<code>hello.c</code>编译生成的可执行文件命名为<code>hello.exe</code>的编译命令为:</p><pre><code class="c">gcc hello.c -o hello.exe</code></pre><p>此时就可以输出<code>hello.exe</code>运行该程序，如：</p><p><a href="https://imgchr.com/i/VH1iG9" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH1iG9.md.png" alt="VH1iG9.md.png"></a></p><p>学会这种编译方式后，之后转到Linux环境下进行编译也是类似的，编译的命令是一样的。之前已经分享过了这个环境的安装配置方法，可能有些朋友还不是很清楚怎么配置（配置方法请查看使用<a href="http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA==&mid=100000123&idx=3&sn=17ee38be930bce0f8e5132bf930acca3&chksm=7e0d6fbc497ae6aadec020b76d411fce1193cc6a0f4926e6871d5a26c2d98f2c479aa2f780bf#rd" target="_blank" rel="noopener">【C语言笔记】使用Notepad++来开发C程序</a>）。</p><p>这不，昨天有位朋友问我怎么在黑窗口下切换路径的问题，因为不会切换路径所以无法找到代码文件的位置。现教大家怎么切换路径：</p><p>（1）首先要知道怎么切换盘符，切换盘符示例：</p><p><a href="https://imgchr.com/i/VH1GsP" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH1GsP.md.png" alt="VH1GsP.md.png"></a></p><p>（2）其次，就可以找到该盘符下你的代码的位置，比如我的代码在<code>D:\c_test</code>路径下，那么我就可以如下操作切换到<code>D:\c_test</code>路径：</p><p><a href="https://imgchr.com/i/VH10Rs" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH10Rs.md.png" alt="VH10Rs.md.png"></a></p><p>还有方法是，你可以直接<code>cd</code>至你源代码所在目录的绝对路径，如：</p><p><a href="https://imgchr.com/i/VH1Wi4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH1Wi4.md.png" alt="VH1Wi4.md.png"></a></p><p><a href="https://imgchr.com/i/VH1zQI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH1zQI.md.png" alt="VH1zQI.md.png"></a></p><p>此外，有两个小技巧要告诉大家：</p><p>（1）<code>【Tab】键</code>具有补齐功能，比如你输出<code>cd c_</code>,然后按下<code>【Tab】键</code>就可以自动补齐为：<code>cd c_test</code>。</p><p>（2）你不记得文件夹的名字时可以输入<code>dir命令</code>（类似于linux系统中的ls命令）查看当前文件夹下的所有文件及文件夹，如：</p><p><a href="https://imgchr.com/i/VH3Cef" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH3Cef.md.png" alt="VH3Cef.md.png"></a></p><p>以上就是在黑窗口下切换至源码路径的一种方法，如果你不会的话，还有另一种更为简单的方法：</p><p>在记事本中就可以很方便的在黑窗口中打开你的源码所在的路径：</p><p><a href="https://imgchr.com/i/VH3MwT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH3MwT.md.png" alt="VH3MwT.md.png"></a></p><p>既然已经讲了那么多了，就顺便讲一下多个文件该怎么编译。其实和编译一个文件也差不多，编译多个文件就把要编译的文件都加到编译命令中就可以了，如：</p><pre><code class="c">gcc cJSON.c json_parse_now.c -o test.exe</code></pre><p>该命令同时编译链接<code>JSON.c</code>和<code>json_parse_now.c</code>文件。</p><p>以上就是关于如何在window命令行下编译C程序的一点补充的笔记，掌握这一点就可以无缝切换到Linux下进行编译C程序了（相关笔记：<a href="http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA==&mid=100000740&idx=1&sn=f2b589c6930bb6576b5f59997dbef111&chksm=7e0d6d23497ae43532bc906510246c23a885d71ad56225eb7af95db5fb6278802bd66e875c23#rd" target="_blank" rel="noopener">【C语言笔记】windows下体验Linux环境</a>）。关于C程序的编译过程可查看往期笔记：<a href="http://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA==&mid=100000314&idx=1&sn=ab21fd8bf68569b82ffe221f2af3058f&chksm=7e0d6cfd497ae5eb188e9ff85cd0e4d6dd0a491b45263033588b14a80f9c40cd6cbca7f3f2bd#rd" target="_blank" rel="noopener">【C语言笔记】你知道C语言编译的过程吗？</a></p><p>以上就是关于在windows命令行编译C程序的方法，如有错误，欢迎指出！</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有关注我的朋友可能会知道我的C开发环境是：&lt;code&gt;Notepad++&lt;/code&gt;与&lt;code&gt;MinGW&lt;/code&gt;相结合，即用&lt;code&gt;Notepad++&lt;/code&gt;写代码，用&lt;code&gt;MinGW&lt;/code&gt;这个工具包中的&lt;code&gt;gcc编译器&lt;/cod
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】分享一个C语言测试程序模板</title>
    <link href="https://zhengnianli.github.io/2018/12/14/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AAC%E8%AF%AD%E8%A8%80%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%9D%BF/"/>
    <id>https://zhengnianli.github.io/2018/12/14/【C语言笔记】分享一个C语言测试程序模板/</id>
    <published>2018-12-14T00:22:15.000Z</published>
    <updated>2019-06-17T15:03:53.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>平时需要测试一些比较模糊的知识点，或则想要验证一些函数时，我们常常会建一个<code>test.c</code>文件，然后在这个文件里写我们的测试代码，测试完毕后常常会删掉该文件。下次再遇到同样的问题的时候，可能又是记不清楚了，常常又需要测试一遍，这是件很浪费时间的事情。</p><p>所以，我们可以编写一个专门用于测试的程序：（1）有菜单，可以通过菜单选择想要测试的函数；（2）有功能函数，把一些需要测试的功能封装成一个函数；（3）有测试函数，用于测试功能函数及一些知识点。</p><p>该测试程序大致如下：</p><p><a href="https://imgchr.com/i/V7zbaF" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/V7zbaF.md.png" alt="V7zbaF.md.png"></a></p><p>我们只要输入菜单前面的数字就可以进行对应的测试啦。挺方便的，日积月累，渐渐的，就可以积累很多知识点。如：</p><p><a href="https://imgchr.com/i/V7zXG9" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/V7zXG9.md.png" alt="V7zXG9.md.png"></a></p><h3 id="该测试程序代码模板"><a href="#该测试程序代码模板" class="headerlink" title="该测试程序代码模板"></a>该测试程序代码模板</h3><h3 id="1、菜单函数如下："><a href="#1、菜单函数如下：" class="headerlink" title="1、菜单函数如下："></a>1、菜单函数如下：</h3><p><a href="https://imgchr.com/i/V7zvx1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/V7zvx1.md.png" alt="V7zvx1.md.png"></a></p><h3 id="2、主函数如下："><a href="#2、主函数如下：" class="headerlink" title="2、主函数如下："></a>2、主函数如下：</h3><p><a href="https://imgchr.com/i/VHSiIe" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHSiIe.md.png" alt="VHSiIe.md.png"></a></p><h3 id="3、该测试程序函数声明部分如下"><a href="#3、该测试程序函数声明部分如下" class="headerlink" title="3、该测试程序函数声明部分如下"></a>3、该测试程序函数声明部分如下</h3><p><a href="https://imgchr.com/i/VHSeMt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHSeMt.md.png" alt="VHSeMt.md.png"></a></p><p>完整程序</p><pre><code class="c">/*---------------------------------------------------------------------------------------- 程序说明：这是一个测试程序 创建日期：2018.12.14 by LiZhengNian----------------------------------------------------------------------------------------*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;// 功能函数声明void exchange(int *a, int *b);  // 交换a，b的值最好的方法// 测试函数声明void test1(void);  // 测试函数1：交换a，b的值void test2(void);  // 测试函数2：C语言预定义宏void test3(void);  // 测试函数3：C89与C99标准的区别void test4(void);  // 测试函数4：输出当前编译器数据类型范围// 菜单int menu(void);/*=============================================================================               主函数==============================================================================*/int main(void){ int cmd = 0; for (;;)      // 死循环，等价于while(1) {   cmd = menu(); // 读取用户输入的指令   switch (cmd)   {     case 1 : test1();     break;  // 测试函数1：交换a，b的值     case 2 : test2();     break;  // 测试函数2：C语言预定义宏     case 3 : test3();     break;  // 测试函数3：C89与C99标准的区别     case 4 : test4();     break;  // 测试函数4：输出当前编译器数据类型范围     case -1: exit(0);      break;  // 退出程序     case -2: system(&quot;cls&quot;); break;  // 清空屏幕     default:break;   } } return 0;}/*=============================================================================               以下是功能函数实体==============================================================================*//* 交换a，b的值 */void exchange(int *a, int *b){ *a = *a^*b; *b = *a^*b; *a = *a^*b;}/*=============================================================================               以下是测试函数实体==============================================================================*//* 交换a，b的值 */void test1(void){ system(&quot;cls&quot;); int a = 13, b = 14; printf(&quot;交换之前a = %d, b = %d\n&quot;, a, b); exchange(&amp;a, &amp;b); printf(&quot;交换之后a = %d, b = %d\n&quot;, a, b);}/* C语言预定义宏 */void test2(void){ system(&quot;cls&quot;); printf(&quot;当前代码行号：%d\n&quot;, __LINE__); printf(&quot;当前编译日期：%s\n&quot;, __DATE__); printf(&quot;当前编译时间：%s\n&quot;, __TIME__); printf(&quot;当前文件名称：%s\n&quot;, __FILE__); printf(&quot;当前函数名称：%s\n&quot;, __FUNCTION__);}/* C89与C99标准的区别 */void test3(void){ int i; system(&quot;cls&quot;); // C99允许在for循环内定义循环变量，而C89不允许 // gcc -std=c99 test.c -o test.exe // for (int i = 0; i &lt; 5; i++)   for (i = 0; i &lt; 5; i++) {   printf(&quot;hello world!\n&quot;); }}/* 输出当前编译器数据类型范围 */void test4(void){ system(&quot;cls&quot;); printf(&quot;char的范围为: %d —— %d\n&quot;, CHAR_MIN, CHAR_MAX); printf(&quot;unsigned char的范围为: %u —— %u\n\n&quot;, 0, UCHAR_MAX); printf(&quot;short的范围为: %hd —— %hd\n&quot;, SHRT_MIN, SHRT_MAX); printf(&quot;unsigned short的范围为: %hu —— %hu\n\n&quot;, 0, USHRT_MAX); printf(&quot;int的范围为: %d —— %d\n&quot;, INT_MIN, INT_MAX); printf(&quot;unsigned int的范围为: %u —— %u\n\n&quot;, 0, UINT_MAX); printf(&quot;long的范围为: %ld —— %ld\n&quot;, LONG_MIN, LONG_MAX); printf(&quot;unsigned long的范围为: %lu —— %lu\n\n&quot;, 0, ULONG_MAX); printf(&quot;long long的范围为: %lld —— %lld\n&quot;, LLONG_MIN, LLONG_MAX); printf(&quot;unsigned long long的范围为: %llu —— %llu\n\n&quot;, 0, ULLONG_MAX);}/*=============================================================================               以下是菜单函数==============================================================================*/int menu(void){ int cmd = 0; char buf[10] = {0}; // 菜单信息输出 printf(&quot;=============================菜单==============================\n&quot;); printf(&quot;[01]测试：交换a，b的值\n&quot;); printf(&quot;[02]测试：C语言预定义宏\n&quot;); printf(&quot;[03]测试：C89与C99标准的区别\n&quot;); printf(&quot;[04]测试：输出当前编译器数据类型范围\n&quot;); printf(&quot;[-1]退出\n&quot;); printf(&quot;[-2]清屏\n&quot;); printf(&quot;===============================================================\n&quot;); do{   printf(&quot;请输入您的选择：&quot;);   gets(buf);   cmd = atoi(buf); }while (cmd &lt; 1 &amp;&amp; cmd &gt; 4); return cmd;}</code></pre><p>每当需要测试一些知识点时，就可以按照这样子的格式在后边添加，可以很好地进行积累。</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;平时需要测试一些比较模糊的知识点，或则想要验证一些函数时，我们常常会建一个&lt;code&gt;test.c&lt;/code&gt;文件，然后在这个文件里写我们
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】如何查看数据类型范围？</title>
    <link href="https://zhengnianli.github.io/2018/12/07/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%8C%83%E5%9B%B4%EF%BC%9F/"/>
    <id>https://zhengnianli.github.io/2018/12/07/【C语言笔记】如何查看数据类型范围？/</id>
    <published>2018-12-07T05:59:36.000Z</published>
    <updated>2019-06-17T12:57:54.395Z</updated>
    
    <content type="html"><![CDATA[<h3 id="知识点一：查看整数范围"><a href="#知识点一：查看整数范围" class="headerlink" title="知识点一：查看整数范围"></a>知识点一：查看整数范围</h3><p>当前的编译环境下，你可能不知道int的数据范围是多少，或者记不清无符号短整型的范围是<code>0~65535</code>还是<code>0~65536</code>?这时候就可以按照如下程序进行输出查看：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;limits.h&gt;/* 输出当前编译器数据类型范围 */int main(void){ printf(&quot;\nchar的范围为: %d —— %d\n&quot;, CHAR_MIN, CHAR_MAX); printf(&quot;unsigned char的范围为: %u —— %u\n\n&quot;, 0, UCHAR_MAX); printf(&quot;short的范围为: %hd —— %hd\n&quot;, SHRT_MIN, SHRT_MAX); printf(&quot;unsigned short的范围为: %hu —— %hu\n\n&quot;, 0, USHRT_MAX); printf(&quot;int的范围为: %d —— %d\n&quot;, INT_MIN, INT_MAX); printf(&quot;unsigned int的范围为: %u —— %u\n\n&quot;, 0, UINT_MAX); printf(&quot;long的范围为: %ld —— %ld\n&quot;, LONG_MIN, LONG_MAX); printf(&quot;unsigned long的范围为: %lu —— %lu\n\n&quot;, 0, ULONG_MAX); printf(&quot;long long的范围为: %lld —— %lld\n&quot;, LLONG_MIN, LLONG_MAX); printf(&quot;unsigned long long的范围为: %llu —— %llu\n\n&quot;, 0, ULLONG_MAX); return 0;}</code></pre><p>程序输出结果为：</p><p><a href="https://imgchr.com/i/VH925D" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH925D.md.png" alt="VH925D.md.png"></a></p><p>其中，<code>CHAR_MIN</code>、<code>CHAR_MAX</code>等符号常量是从哪来的呢？其实这些符号常量是头文件<code>limits.h</code>里的宏定义，<code>limits.h</code>内容部分截图如下：</p><p><a href="https://imgchr.com/i/VH9h2d" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH9h2d.md.png" alt="VH9h2d.md.png"></a></p><p>以上输出的范围中，<code>long long</code>与<code>unsigned long long</code>是<code>C99标准</code>引进的新的数据类型，关于C语言的几个标准可以查看小编的上一篇笔记：【C语言笔记】什么是ANSI C标准？</p><h3 id="知识点二：C语言的预定义宏"><a href="#知识点二：C语言的预定义宏" class="headerlink" title="知识点二：C语言的预定义宏"></a>知识点二：C语言的预定义宏</h3><p>标准C语言预处理要求定义某些对象宏，每个预定义宏的名称由两个下划线开头和两个下划线结尾，这些预定义宏不能被取消定义<code>（#undef）</code>。</p><p>常用的几个预处理宏有：</p><pre><code class="c">__LINE__：表示当前源代码的行号；__FILE__：表示当前源文件的名称；__DATE__：表示当前的编译日期；__TIME__：表示当前的编译时间；__FUNCTION__：表示当前函数；</code></pre><p>代码演示：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void){ printf(&quot;\n&quot;); printf(&quot;当前代码行号：%d\n&quot;, __LINE__); printf(&quot;当前编译日期：%s\n&quot;, __DATE__); printf(&quot;当前编译时间：%s\n&quot;, __TIME__); printf(&quot;当前文件名称：%s\n&quot;, __FILE__); printf(&quot;当前函数名称：%s\n&quot;, __FUNCTION__); return 0;}</code></pre><p>程序输出结果为：</p><p><a href="https://imgchr.com/i/VH9XGQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VH9XGQ.md.png" alt="VH9XGQ.md.png"></a></p><p>预定义宏常用于程序运行异常的跟踪，<code>__FILE__</code>，<code>__LINE__</code>，<code>__FUNCTION__</code>这是最常用的组合，表示文件名、行数和函数名。除了以上提到的这五个预定义宏之外，还有<code>C99标准</code>提出的预定义宏如：<code>__STDC_HOSTED__</code>等，有兴趣的可以查一下。</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;知识点一：查看整数范围&quot;&gt;&lt;a href=&quot;#知识点一：查看整数范围&quot; class=&quot;headerlink&quot; title=&quot;知识点一：查看整数范围&quot;&gt;&lt;/a&gt;知识点一：查看整数范围&lt;/h3&gt;&lt;p&gt;当前的编译环境下，你可能不知道int的数据范围是多少，或者记不清无符
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】什么是ANSI C标准？</title>
    <link href="https://zhengnianli.github.io/2018/12/06/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AFANSI%20C%E6%A0%87%E5%87%86%EF%BC%9F/"/>
    <id>https://zhengnianli.github.io/2018/12/06/【C语言笔记】什么是ANSI C标准？/</id>
    <published>2018-12-06T00:22:15.000Z</published>
    <updated>2019-06-17T14:32:31.311Z</updated>
    
    <content type="html"><![CDATA[<p>我们在很多地方都有看到过<code>K&amp;R C、ANSI C、ISO C、C89、C99、C11</code>等标准，具体有什么不同呢？（文末有个很好的实例）</p><h3 id="什么是K-amp-R-C？"><a href="#什么是K-amp-R-C？" class="headerlink" title="什么是K&amp;R C？"></a>什么是K&amp;R C？</h3><p><code>1978</code>年，<code>丹尼斯•里奇（Dennis Ritchie）</code>和<code>布莱恩•柯林汉（Brian Kernighan）</code>合作出版了<code>《C程序设计语言》</code>的第一版。书中介绍的C语言标准也被称作<code>K&amp;R C</code>。</p><h3 id="什么是ANSI-C、ISO-C、C89、C90标准？"><a href="#什么是ANSI-C、ISO-C、C89、C90标准？" class="headerlink" title="什么是ANSI C、ISO C、C89、C90标准？"></a>什么是ANSI C、ISO C、C89、C90标准？</h3><p>随着C语言使用得越来越广泛，出现了许多新问题，人们日益强烈地要求对C语言进行标准化。<code>1983</code>年，<code>美国国家标准协会（ANSI）</code>组成了一个委员会，<code>X3J11</code>，为了创立 C 的一套标准。经过漫长而艰苦的过程，该标准于<code>1989</code>年完成，这个版本的语言经常被称作<code>ANSI C</code>，或有时称为<code>C89</code>（为了区别<code>C99</code>）。在<code>1990</code>年，<code>ANSI C</code>标准（带有一些小改动）被美国国家标准协会（ANSI）采纳为<code>ISO/IEC 9899:1990</code>。这个版本有时候称为<code>C90</code>或者<code>ISO C</code>。综上，<code>ANSI C、ISO C、C89、C90其实是同一种标准</code>。</p><h3 id="什么是C99标准？"><a href="#什么是C99标准？" class="headerlink" title="什么是C99标准？"></a>什么是C99标准？</h3><p><code>2000</code>年3月，<code>ANSI</code>采纳<code>了 ISO/IEC 9899:1999 标准</code>。这个标准通常指<code>C99</code>。 <code>C99</code>新增了一些特性，如：支持不定长的数组，即数组长度可以在运行时决定。变量声明不必放在语句块的开头，for语句提倡写成<code>for(int i=0;i&lt;100;++i)</code> 的形式，即i只在for语句块内部有效。</p><h3 id="什么是C11标准？"><a href="#什么是C11标准？" class="headerlink" title="什么是C11标准？"></a>什么是C11标准？</h3><p><code>C11标准</code>是C语言标准的第三版（<code>2011年由ISO/IEC发布</code>），前一个标准版本是<code>C99标准</code>。与<code>C99</code>相比，<code>C11</code>有哪些变化呢？</p><pre><code class="cpp">1、 对齐处理：alignof(T)返回T的对齐方式，aligned_alloc()以指定字节和对齐方式分配内存，头文件&lt;stdalign.h&gt;定义了这些内容。2、 _Noreturn：_Noreturn是个函数修饰符，位置在函数返回类型的前面，声明函数无返回值，有点类似于gcc的__attribute__((noreturn))，后者在声明语句尾部。3、 _Generic：_Generic支持轻量级范型编程，可以把一组具有不同类型而却有相同功能的函数抽象为一个接口。4、 _Static_assert()：_Static_assert()，静态断言，在编译时刻进行，断言表达式必须是在编译时期可以计算的表达式，而普通的assert()在运行时刻断言。5、安全版本的几个函数：gets_s()取代了gets()，原因是后者这个I/O函数的实际缓冲区大小不确定，以至于发生常见的缓冲区溢出攻击，类似的函数还有其它的。6、 fopen()新模式：fopen()增加了新的创建、打开模式“x”，在文件锁中比较常用。7、 匿名结构体、联合体。8、 多线程：头文件&lt;threads.h&gt;定义了创建和管理线程的函数，新的存储类修饰符_Thread_local限定了变量不能在多线程之间共享。9、 _Atomic类型修饰符和头文件&lt;stdatomic.h&gt;。10、改进的Unicode支持和头文件&lt;uchar.h&gt;。11、quick_exit()：又一种终止程序的方式，当exit()失败时用以终止程序。12、复数宏，浮点数宏。13、time.h新增timespec结构体，时间单位为纳秒，原来的timeval结构体时间单位为毫秒。</code></pre><p>下面看一段程序：</p><pre><code class="cpp">#include &lt;stdio.h&gt;int main(void){ // C99允许在for循环内定义循环变量，而C89不允许 for (int i = 0; i &lt; 5; i++)     {   printf(&quot;hello world!\n&quot;); }   return 0;}</code></pre><p>在<code>C89标准</code>下编译，结果为：</p><p><a href="https://imgchr.com/i/VHJM0P" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHJM0P.md.png" alt="VHJM0P.md.png"></a></p><p>编译报错原因为，在<code>C89标准</code>下，循环变量不能在for循环内定义，必须把标准改为<code>C99标准</code>才可正常编译。以<code>C99</code>编译的命令为：</p><pre><code class="cpp">gcc -std=c99 test.c -o test.exe</code></pre><p>如下图，以C99编译能成功编译：</p><p><a href="https://imgchr.com/i/VHJ8fg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/17/VHJ8fg.md.png" alt="VHJ8fg.md.png"></a></p><p>所以在平时的开发中应该要了解编译器支持什么标准。因为，有时候编译出错是因为当前编译器支持的标准不同。</p><p><code>GCC编译器</code>在编译的时候可指定C语言标准：</p><pre><code class="cpp">指定c90标准: -std=c90指定C99标准: -std=c99定C11标准(目前正在开发中): -std=c11</code></pre><p>以上就是关于C语言标准的笔记，如有错误欢迎指出！</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在很多地方都有看到过&lt;code&gt;K&amp;amp;R C、ANSI C、ISO C、C89、C99、C11&lt;/code&gt;等标准，具体有什么不同呢？（文末有个很好的实例）&lt;/p&gt;
&lt;h3 id=&quot;什么是K-amp-R-C？&quot;&gt;&lt;a href=&quot;#什么是K-amp-R-C？&quot; c
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【C语言笔记】ASCII码可见字符与不可见字符</title>
    <link href="https://zhengnianli.github.io/2018/11/26/%E3%80%90C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%91ASCII%E7%A0%81%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6%E4%B8%8E%E4%B8%8D%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6/"/>
    <id>https://zhengnianli.github.io/2018/11/26/【C语言笔记】ASCII码可见字符与不可见字符/</id>
    <published>2018-11-26T00:22:15.000Z</published>
    <updated>2019-06-18T06:03:46.900Z</updated>
    
    <content type="html"><![CDATA[<p><code>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）</code>是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。下面看一段示例代码，用于输出ASCII码：</p><pre><code class="c">#include &lt;stdio.h&gt;int main(void){ int c; printf(&quot;\t字符\t十进制\n&quot;); for(c = 0; c &lt; 128; c++) {   printf(&quot;\t%c\t%4d\n&quot;, c, c); }   return 0;}</code></pre><p>输出结果发现：</p><p><a href="https://imgchr.com/i/Voedud" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/15/Voedud.md.png" alt="Voedud.md.png"></a></p><p><a href="https://imgchr.com/i/VoTZgH" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/15/VoTZgH.md.png" alt="VoTZgH.md.png"></a></p><p>从输出结果可以发现，ASCII码0-32及127对应的字符的显示是不正常的，这些显示不正常的就是不可打印字符，不可打印字符也叫控制字符，其他能显示出来的就是打印字符。</p><p>完整ASCII表如下（图片来源于网络）：</p><p><a href="https://imgchr.com/i/VoT7xH" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/15/VoT7xH.md.png" alt="VoT7xH.md.png"></a></p><p>从这个表中，我们还看到有转义字符这一名词。转义字符是什么呢？C语言中定义了一些字母前加”&quot;来表示常见的那些不能显示的ASCII字符，如我们上面的代码用的\t、\n等，就称为<code>转义字符</code>，因为后面的字符，都不是它本来的ASCII字符意思了。</p><p>转义字符对应表如下（图片来源于网络）：</p><p><a href="https://imgchr.com/i/VTkttU" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/VTkttU.md.png" alt="VTkttU.md.png"></a></p><p>以上就是关于ASCII码的一点笔记。ASCII码有可见字符与不可见字符（控制字符）之分。其中一些常用的不可见字符可用一些字母前加”&quot;来表示，也即转义字符。</p><hr><p><a href="https://imgchr.com/i/VcSFJJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/11/VcSFJJ.md.png" alt="VcSFJJ.md.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）&lt;/code&gt;是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。下面看一段示例代码，用于输出ASCII码：
      
    
    </summary>
    
      <category term="C语言笔记" scheme="https://zhengnianli.github.io/categories/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="https://zhengnianli.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
